.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Slurm 3"
.TH Slurm 3 "2018-08-30" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Slurm \- Perl API for libslurm
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Slurm;
\&
\&    my $slurm = Slurm::new();
\&    $nodes = $slurm\->load_node();
\&    unless($nodes) {
\&        die "failed to load node info: " . $slurm\->strerror();
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Slurm class provides Perl interface of the \s-1SLURM API\s0 functions in \f(CW\*(C`<slurm/slurm.h>\*(C'\fR, with some extra frequently used functions exported by libslurm.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
To use the \s-1API,\s0 first create a Slurm object:
.PP
.Vb 1
\&    $slurm = Slurm::new($conf);
.Ve
.PP
Then call the desired functions:
.PP
.Vb 1
\&    $resp = $slurm\->load_jobs();
.Ve
.PP
In the following \*(L"\s-1METHODS\*(R"\s0 section, if a parameter is omitted, it will be listed as \*(L"param=val\*(R" , where \*(L"val\*(R" is the default value of the parameter.
.SS "\s-1DATA STRUCTURES\s0"
.IX Subsection "DATA STRUCTURES"
Typically, C structures are converted to (maybe blessed) Perl hash references, with field names as hash keys. Arrays in C are converted to arrays in Perl. For example, there is a structure \f(CW\*(C`job_info_msg_t\*(C'\fR:
.PP
.Vb 5
\&    typedef struct job_info_msg {
\&        time_t last_update;     /* time of latest info */
\&        uint32_t record_count;  /* number of records */
\&        job_info_t *job_array;  /* the job records */
\&    } job_info_msg_t;
.Ve
.PP
This will be converted to a hash reference with the following structure:
.PP
.Vb 7
\&    {
\&        last_update => 1285847672,
\&        job_array => [ {account => \*(Aqtest\*(Aq, alloc_node => \*(Aqln0\*(Aq, alloc_sid => 1234, ...},
\&                       {account => \*(Aqdebug\*(Aq, alloc_node => \*(Aqln2\*(Aq, alloc_sid => 5678, ...},
\&                       ...
\&                     ]
\&    }
.Ve
.PP
Note the missing of the \f(CW\*(C`record_count\*(C'\fR field in the hash. It can be derived from the number of elements in array \f(CW\*(C`job_array\*(C'\fR.
.PP
To pass parameters to the \s-1API\s0 functions, use the corresponding hash references, for example:
.PP
.Vb 1
\&    $rc = $slurm\->update_node({node_names => \*(Aqnode[0\-7]\*(Aq, node_state => NODE_STATE_DRAIN});
.Ve
.PP
Please see \f(CW\*(C`<slurm/slurm.h>\*(C'\fR for the definition of the structures.
.SS "\s-1CONSTANTS\s0"
.IX Subsection "CONSTANTS"
The enumerations and macro definitions are available in the Slurm package. If ':constant' is given when using the Slurm package, the constants will be exported to the calling package.
.PP
Please see Slurm::Constant for the available constants.
.SH "METHODS"
.IX Header "METHODS"
.SS "\s-1CONSTRUCTOR/DESTRUCTOR\s0"
.IX Subsection "CONSTRUCTOR/DESTRUCTOR"
\fI\f(CI$slurm\fI = Slurm::new($conf_file=undef);\fR
.IX Subsection "$slurm = Slurm::new($conf_file=undef);"
.PP
Create a Slurm object. For now the object is just a hash reference with no members.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$conf_file:\fR the \s-1SLURM\s0 configuration file. If omitted, the default \s-1SLURM\s0 configuration file will be used (file specified by environment variable \s-1SLURM_CONF\s0 or the file slurm.conf under directroy specified in compile time).
.IP "\(bu" 2
\&\s-1RET:\s0 blessed opaque Slurm object. On error \f(CW\*(C`undef\*(C'\fR is returned.
.SS "\s-1ERROR INFORMATION FUNCTIONS\s0"
.IX Subsection "ERROR INFORMATION FUNCTIONS"
\fI\f(CI$errno\fI = \f(CI$slurm\fI\->\fIget_errno()\fI;\fR
.IX Subsection "$errno = $slurm->get_errno();"
.PP
Get the error number associated with last operation.
.IP "\(bu" 2
\&\s-1RET:\s0 error number associated with last operation.
.PP
\fI\f(CI$str\fI = \f(CI$slurm\fI\->strerror($errno=0)\fR
.IX Subsection "$str = $slurm->strerror($errno=0)"
.PP
Get the string describing the specified error number.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$errno:\fR error number. If omitted or 0, the error number returned by \f(CW\*(C`$slurm\-\*(C'\fR\fIget_errno()\fR> will be used.
.IP "\(bu" 2
\&\s-1RET:\s0 error string.
.SS "\s-1ENTITY STATE/REASON/FLAG/TYPE STRING FUNCTIONS\s0"
.IX Subsection "ENTITY STATE/REASON/FLAG/TYPE STRING FUNCTIONS"
\fI\f(CI$str\fI = \f(CI$slurm\fI\->preempt_mode_string($mode_num);\fR
.IX Subsection "$str = $slurm->preempt_mode_string($mode_num);"
.PP
Get the string describing the specified preemt mode number.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$mode_num:\fR preempt mode number.
.IP "\(bu" 2
\&\s-1RET:\s0 preempt mode string.
.PP
\fI\f(CI$num\fI = \f(CI$slurm\fI\->preempt_mode_num($mode_str);\fR
.IX Subsection "$num = $slurm->preempt_mode_num($mode_str);"
.PP
Get the preempt mode number of the specified preempt mode string.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$mode_str:\fR preempt mode string.
.IP "\(bu" 2
\&\s-1RET:\s0 preempt mode number.
.PP
\fI\f(CI$str\fI = \f(CI$slurm\fI\->job_reason_string($num);\fR
.IX Subsection "$str = $slurm->job_reason_string($num);"
.PP
Get the string representation of the specified job state reason number.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$num:\fR job reason number.
.IP "\(bu" 2
\&\s-1RET:\s0 job reason string.
.PP
\fI\f(CI$str\fI = \f(CI$slurm\fI\->job_state_string($num);\fR
.IX Subsection "$str = $slurm->job_state_string($num);"
.PP
Get the string representation of the specified job state number.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$num:\fR job state number.
.IP "\(bu" 2
\&\s-1RET:\s0 job state string.
.PP
\fI\f(CI$str\fI = \f(CI$slurm\fI\->job_state_string_compact($num);\fR
.IX Subsection "$str = $slurm->job_state_string_compact($num);"
.PP
Get the compact string representation of the specified job state number.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$num:\fR job state number.
.IP "\(bu" 2
\&\s-1RET:\s0 compact job state string.
.PP
\fI\f(CI$num\fI = \f(CI$slurm\fI\->job_state_num($str);\fR
.IX Subsection "$num = $slurm->job_state_num($str);"
.PP
Get the job state number of the specified (compact) job state string.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$str:\fR job state string.
.IP "\(bu" 2
\&\s-1RET:\s0 job state number.
.PP
\fI\f(CI$str\fI = \f(CI$slurm\fI\->reservation_flags_string($flags);\fR
.IX Subsection "$str = $slurm->reservation_flags_string($flags);"
.PP
Get the string representation of the specified reservation flags.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$num:\fR reservation flags number.
.IP "\(bu" 2
\&\s-1RET:\s0 reservation flags string.
.PP
\fI\f(CI$str\fI = \f(CI$slurm\fI\->node_state_string($num);\fR
.IX Subsection "$str = $slurm->node_state_string($num);"
.PP
Get the string representation of the specified node state number.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$num:\fR node state number.
.IP "\(bu" 2
\&\s-1RET:\s0 node state string.
.PP
\fI\f(CI$str\fI = \f(CI$slurm\fI\->node_state_string_compact($num);\fR
.IX Subsection "$str = $slurm->node_state_string_compact($num);"
.PP
Get the compact string representation of the specified node state number.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$num:\fR node state number.
.IP "\(bu" 2
\&\s-1RET:\s0 compact node state string.
.PP
\fI\f(CI$str\fI = \f(CI$slurm\fI\->private_data_string($num);\fR
.IX Subsection "$str = $slurm->private_data_string($num);"
.PP
Get the string representation of the specified private data type.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$num:\fR private data type number.
.IP "\(bu" 2
\&\s-1RET:\s0 private data type string.
.PP
\fI\f(CI$str\fI = \f(CI$slurm\fI\->accounting_enforce_string($num);\fR
.IX Subsection "$str = $slurm->accounting_enforce_string($num);"
.PP
Get the string representation of the specified accounting enforce type.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$num:\fR accounting enforce type number.
.IP "\(bu" 2
\&\s-1RET:\s0 accounting enforce type string.
.PP
\fI\f(CI$str\fI = \f(CI$slurm\fI\->node_use_string($num);\fR
.IX Subsection "$str = $slurm->node_use_string($num);"
.PP
Get the string representation of the specified node usage type.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$num:\fR node usage type number.
.IP "\(bu" 2
\&\s-1RET:\s0 node usage type string.
.SS "\s-1RESOURCE ALLOCATION FUNCTIONS\s0"
.IX Subsection "RESOURCE ALLOCATION FUNCTIONS"
\fI\f(CI$resp\fI = \f(CI$slurm\fI\->allocate_resources($job_desc);\fR
.IX Subsection "$resp = $slurm->allocate_resources($job_desc);"
.PP
Allocate resources for a job request. If the requested resources are not immediately available, the slurmctld will send the job_alloc_resp_msg to the sepecified node and port.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_desc:\fR description of resource allocation request, with structure of \f(CW\*(C`job_desc_msg_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1RET:\s0 response to request, with structure of \f(CW\*(C`resource_allocation_response_msg_t\*(C'\fR.  This only represents a job allocation if resources are immediately available.  Otherwise it just contains the job id of the enqueued job request. On failure \f(CW\*(C`undef\*(C'\fR is returned.
.PP
\fI\f(CI$resp\fI = \f(CI$slurm\fI\->allocate_resources_blocking($job_desc, \f(CI$timeout\fI=0, \f(CI$pending_callbacks\fI=undef);\fR
.IX Subsection "$resp = $slurm->allocate_resources_blocking($job_desc, $timeout=0, $pending_callbacks=undef);"
.PP
Allocate resources for a job request.  This call will block until the allocation is granted, or the specified timeout limit is reached.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_desc:\fR description of resource allocation request, with structure of \f(CW\*(C`job_desc_msg_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$timeout:\fR amount of time, in seconds, to wait for a response before giving up. A timeout of zero will wait indefinitely.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$pending_callbacks:\fR If the allocation cannot be granted immediately, the controller will put the job in the \s-1PENDING\s0 state.  If
pending callback is given, it will be called with the job id of the pending job as the sole parameter.
.IP "\(bu" 2
\&\s-1RET:\s0 allcation response, with structure of \f(CW\*(C`resource_allocation_response_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned, with errno set.
.PP
\fI\f(CI$resp\fI = \f(CI$slurm\fI\->allocatiion_lookup($job_id);\fR
.IX Subsection "$resp = $slurm->allocatiion_lookup($job_id);"
.PP
Retrieve info for an existing resource allocation.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR job allocation identifier.
.IP "\(bu" 2
\&\s-1RET:\s0 job allocation info, with structure of \f(CW\*(C`resource_allocation_response_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fI\f(CI$str\fI = \f(CI$slurm\fI\->read_hostfile($filename, \f(CI$n\fI);\fR
.IX Subsection "$str = $slurm->read_hostfile($filename, $n);"
.PP
Read a specified \s-1SLURM\s0 hostfile. The file must contain a list of \s-1SLURM\s0 NodeNames, one per line.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$filename:\fR name of \s-1SLURM\s0 hostlist file to be read.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$n:\fR number of NodeNames required.
.IP "\(bu" 2
\&\s-1RET:\s0 a string representing the hostlist. Returns \s-1NULL\s0 if there are fewer than \f(CW$n\fR hostnames in the file, or if an error occurs.
.PP
\fI\f(CI$msg_thr\fI = \f(CI$slurm\fI\->allocation_msg_thr_create($port, \f(CI$callbacks\fI);\fR
.IX Subsection "$msg_thr = $slurm->allocation_msg_thr_create($port, $callbacks);"
.PP
Startup a message handler talking with the controller dealing with messages from the controller during an allocation.
.IP "\(bu" 2
\&\s-1OUT\s0 \f(CW$port:\fR port we are listening for messages on from the controller.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$callbacks:\fR callbacks for different types of messages, with structure of \f(CW\*(C`slurm_allocation_callbacks_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1RET:\s0 opaque object of \f(CW\*(C`allocation_msg_thread_t *\*(C'\fR,  or \s-1NULL\s0 on failure.
.PP
\fI\f(CI$slurm\fI\->allocation_msg_thr_destroy($msg_thr);\fR
.IX Subsection "$slurm->allocation_msg_thr_destroy($msg_thr);"
.PP
Shutdown the message handler talking with the controller dealing with messages from the controller during an allocation.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$msg_thr:\fR opaque object of \f(CW\*(C`allocation_msg_thread_t\*(C'\fR pointer.
.PP
\fI\f(CI$resp\fI = \f(CI$slurm\fI\->submit_batch_job($job_desc_msg);\fR
.IX Subsection "$resp = $slurm->submit_batch_job($job_desc_msg);"
.PP
Issue \s-1RPC\s0 to submit a job for later execution.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_desc_msg:\fR description of batch job request, with structure of \f(CW\*(C`job_desc_msg_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1RET: 0\s0 on success, otherwise return \-1 and set errno to indicate the error.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->job_will_run($job_desc_msg);\fR
.IX Subsection "$rc = $slurm->job_will_run($job_desc_msg);"
.PP
Determine if a job would execute immediately if submitted now.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_desc_msg:\fR description of resource allocation request, with structure of \f(CW\*(C`job_desc_msg_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1RET: 0\s0 on success, otherwise return \-1 and set errno to indicate the error.
.PP
\fI\f(CI$resp\fI = \f(CI$slurm\fI\->sbcast_lookup($job_id);\fR
.IX Subsection "$resp = $slurm->sbcast_lookup($job_id);"
.PP
Retrieve info for an existing resource allocation including a credential needed for sbcast.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$jobid:\fR job allocation identifier.
.IP "\(bu" 2
\&\s-1RET:\s0 job allocation information includeing a credential for sbcast, with structure of \f(CW\*(C`job_sbcast_cred_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.SS "\s-1JOB/STEP SIGNALING FUNCTIONS\s0"
.IX Subsection "JOB/STEP SIGNALING FUNCTIONS"
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->kill_job($job_id, \f(CI$signal\fI, \f(CI$batch_flag\fI=0);\fR
.IX Subsection "$rc = $slurm->kill_job($job_id, $signal, $batch_flag=0);"
.PP
Send the specified signal to all steps of an existing job.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR the job's id.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$signal:\fR signal number.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$batch_flag:\fR 1 to signal batch shell only, otherwise 0.
.IP "\(bu" 2
\&\s-1RET: 0\s0 on success, otherwise return \-1 and set errno to indicate the error.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->kill_job_step($job_id, \f(CI$step_id\fI, \f(CI$signal\fI);\fR
.IX Subsection "$rc = $slurm->kill_job_step($job_id, $step_id, $signal);"
.PP
Send the specified signal to an existing job step.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR the job's id.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$step_id:\fR the job step's id.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$signal:\fR signal number.
.IP "\(bu" 2
\&\s-1RET: 0\s0 on success, otherwise return \-1 and set errno to indicate the error.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->signal_job($job_id, \f(CI$signal\fI);\fR
.IX Subsection "$rc = $slurm->signal_job($job_id, $signal);"
.PP
Send the specified signal to all steps of an existing job.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR the job's id.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$signal:\fR signal number.
.IP "\(bu" 2
\&\s-1RET: 0\s0 on success, otherwise return \-1 and set errno to indicate the error.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->signal_job_step($job_id, \f(CI$step_id\fI, \f(CI$signal\fI);\fR
.IX Subsection "$rc = $slurm->signal_job_step($job_id, $step_id, $signal);"
.PP
Send the specified signal to an existing job step.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR the job's id.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$step_id:\fR the job step's id.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$signal:\fR signal number.
.IP "\(bu" 2
\&\s-1RET: 0\s0 on success, otherwise return \-1 and set errno to indicate the error.
.SS "\s-1JOB/STEP COMPLETION FUNCTIONS\s0"
.IX Subsection "JOB/STEP COMPLETION FUNCTIONS"
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->complete_job($job_id, \f(CI$job_rc\fI=0);\fR
.IX Subsection "$rc = $slurm->complete_job($job_id, $job_rc=0);"
.PP
Note the completion of a job and all of its steps.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR the job's id.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_rc:\fR the highest exit code of any task of the job.
.IP "\(bu" 2
\&\s-1RET: 0\s0 on success, otherwise return \-1 and set errno to indicate the error.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->terminate_job_step($job_id, \f(CI$step_id\fI);\fR
.IX Subsection "$rc = $slurm->terminate_job_step($job_id, $step_id);"
.PP
Terminates a job step by sending a \s-1REQUEST_TERMINATE_TASKS\s0 rpc to all slurmd of a job step, and then calls \fIslurm_complete_job_step()\fR after verifying that all nodes in the job step no longer have running tasks from the job step.  (May take over 35 seconds to return.)
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR the job's id.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$step_id:\fR the job step's id \- use \s-1SLURM_BATCH_SCRIPT\s0 as the step_id to terminate a job's batch script.
.IP "\(bu" 2
\&\s-1RET: 0\s0 on success, otherwise return \-1 and set errno to indicate the error.
.SS "\s-1SLURM TASK SPAWNING FUNCTIONS\s0"
.IX Subsection "SLURM TASK SPAWNING FUNCTIONS"
\fI\f(CI$ctx\fI = \f(CI$slurm\fI\->step_ctx_create($params);\fR
.IX Subsection "$ctx = $slurm->step_ctx_create($params);"
.PP
Create a job step and its context.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$params:\fR job step parameters, with structure of \f(CW\*(C`slurm_step_ctx_params_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1RET:\s0 the step context. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fI\f(CI$ctx\fI = \f(CI$slurm\fI\->step_ctx_create_no_alloc($params);\fR
.IX Subsection "$ctx = $slurm->step_ctx_create_no_alloc($params);"
.PP
Create a job step and its context without getting an allocation.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$params:\fR job step parameters, with structure of \f(CW\*(C`slurm_step_ctx_params_t\*(C'\fR..
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$step_id:\fR fake job step id.
.IP "\(bu" 2
\&\s-1RET:\s0 the step context. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.SS "\s-1SLURM CONTROL CONFIGURATION READ/PRINT/UPDATE FUNCTIONS\s0"
.IX Subsection "SLURM CONTROL CONFIGURATION READ/PRINT/UPDATE FUNCTIONS"
\fI($major, \f(CI$minor\fI, \f(CI$micro\fI) = \f(CI$slurm\fI\->\fIapi_version()\fI;\fR
.IX Subsection "($major, $minor, $micro) = $slurm->api_version();"
.PP
Get the \s-1SLURM API\s0's version number.
.IP "\(bu" 2
\&\s-1RET:\s0 a three element list of the major, minor, and micro version number.
.PP
\fI\f(CI$resp\fI = \f(CI$slurm\fI\->load_ctl_conf($update_time=0);\fR
.IX Subsection "$resp = $slurm->load_ctl_conf($update_time=0);"
.PP
Issue \s-1RPC\s0 to get \s-1SLURM\s0 control configuration information if changed.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$update_time:\fR time of current configuration data.
.IP "\(bu" 2
\&\s-1RET: SLURM\s0 configuration data, with structure of \f(CW\*(C`slurm_ctl_conf_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fI\f(CI$slurm\fI\->print_ctl_conf($out, \f(CI$conf\fI);\fR
.IX Subsection "$slurm->print_ctl_conf($out, $conf);"
.PP
Output the contents of \s-1SLURM\s0 control configuration message as loaded using \f(CW\*(C`load_ctl_conf()\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$out:\fR file to write to.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$conf:\fR \s-1SLURM\s0 control configuration, with structure of \f(CW\*(C`slurm_ctl_conf_t\*(C'\fR.
.PP
\fI\f(CI$list\fI = \f(CI$slurm\fI\->ctl_conf_2_key_pairs($conf);\fR
.IX Subsection "$list = $slurm->ctl_conf_2_key_pairs($conf);"
.PP
Put the \s-1SLURM\s0 configuration data into a List of opaque data type \f(CW\*(C`config_key_pair_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$conf:\fR \s-1SLURM\s0 control configuration, with structure of \f(CW\*(C`slurm_ctl_conf_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1RET:\s0 List of opaque data type \f(CW\*(C`config_key_pair_t\*(C'\fR.
.PP
\fI\f(CI$resp\fI = \f(CI$slurm\fI\->\fIload_slurmd_status()\fI;\fR
.IX Subsection "$resp = $slurm->load_slurmd_status();"
.PP
Issue \s-1RPC\s0 to get the status of slurmd daemon on this machine.
.IP "\(bu" 2
\&\s-1RET:\s0 slurmd status info, with structure of \f(CW\*(C`slurmd_status_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fI\f(CI$slurm\fI\->print_slurmd_status($out, \f(CI$slurmd_status\fI);\fR
.IX Subsection "$slurm->print_slurmd_status($out, $slurmd_status);"
.PP
Output the contents of slurmd status message as loaded using \f(CW\*(C`load_slurmd_status()\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$out:\fR file to write to.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$slurmd_status:\fR slurmd status info, with structure of \f(CW\*(C`slurmd_status_t\*(C'\fR.
.PP
\fI\f(CI$slurm\fI\->print_key_pairs($out, \f(CI$key_pairs\fI, \f(CI$title\fI);\fR
.IX Subsection "$slurm->print_key_pairs($out, $key_pairs, $title);"
.PP
Output the contents of key_pairs which is a list of opaque data type \f(CW\*(C`config_key_pair_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$out:\fR file to write to.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$key_pairs:\fR List containing key pairs to be printed.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$title:\fR title of key pair list.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->update_step($step_msg);\fR
.IX Subsection "$rc = $slurm->update_step($step_msg);"
.PP
Update the time limit of a job step.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$step_msg:\fR step update messasge descriptor, with structure of \f(CW\*(C`step_update_request_msg_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1RET: 0\s0 or \-1 on error.
.SS "\s-1SLURM JOB RESOURCES READ/PRINT FUNCTIONS\s0"
.IX Subsection "SLURM JOB RESOURCES READ/PRINT FUNCTIONS"
\fI\f(CI$num\fI = \f(CI$slurm\fI\->job_cpus_allocated_on_node_id($job_res, \f(CI$node_id\fI);\fR
.IX Subsection "$num = $slurm->job_cpus_allocated_on_node_id($job_res, $node_id);"
.PP
Get the number of cpus allocated to a job on a node by node id.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_res:\fR job resources data, with structure of \f(CW\*(C`job_resources_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$node_id:\fR zero-origin node id in allocation.
.IP "\(bu" 2
\&\s-1RET:\s0 number of CPUs allocated to job on this node or \-1 on error.
.PP
\fI\f(CI$num\fI = \f(CI$slurm\fI\->job_cpus_allocated_on_node($job_res, \f(CI$node_name\fI);\fR
.IX Subsection "$num = $slurm->job_cpus_allocated_on_node($job_res, $node_name);"
.PP
Get the number of cpus allocated to a job on a node by node name.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_res:\fR job resources data, with structure of \f(CW\*(C`job_resources_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$node_name:\fR name of node.
.IP "\(bu" 2
\&\s-1RET:\s0 number of CPUs allocated to job on this node or \-1 on error.
.SS "\s-1SLURM JOB CONFIGURATION READ/PRINT/UPDATE FUNCTIONS\s0"
.IX Subsection "SLURM JOB CONFIGURATION READ/PRINT/UPDATE FUNCTIONS"
\fI\f(CI$time\fI = \f(CI$slurm\fI\->get_end_time($job_id);\fR
.IX Subsection "$time = $slurm->get_end_time($job_id);"
.PP
Get the expected end time for a given slurm job.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$jobid:\fR \s-1SLURM\s0 job id.
.IP "\(bu" 2
\&\s-1RET:\s0 scheduled end time for the job. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fI\f(CI$secs\fI = \f(CI$slurm\fI\->get_rem_time($job_id);\fR
.IX Subsection "$secs = $slurm->get_rem_time($job_id);"
.PP
Get the expected time remaining for a given job.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$jobid:\fR \s-1SLURM\s0 job id.
.IP "\(bu" 2
\&\s-1RET:\s0 remaining time in seconds or \-1 on error.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->job_node_ready($job_id);\fR
.IX Subsection "$rc = $slurm->job_node_ready($job_id);"
.PP
Report if nodes are ready for job to execute now.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR \s-1SLURM\s0 job id.
.IP "\(bu" 2
\&\s-1RET: \s0
.RS 2
.IP "\(bu" 2
\&\s-1READY_JOB_FATAL:\s0 fatal error
.IP "\(bu" 2
\&\s-1READY_JOB_ERROR:\s0 ordinary error
.IP "\(bu" 2
\&\s-1READY_NODE_STATE:\s0 node is ready
.IP "\(bu" 2
\&\s-1READY_JOB_STATE:\s0 job is ready to execute
.RE
.RS 2
.RE
.PP
\fI\f(CI$resp\fI = \f(CI$slurm\fI\->load_job($job_id, \f(CI$show_flags\fI=0);\fR
.IX Subsection "$resp = $slurm->load_job($job_id, $show_flags=0);"
.PP
Issue \s-1RPC\s0 to get job information for one job \s-1ID.\s0
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR \s-1ID\s0 of job we want information about.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$show_flags:\fR job filtering options.
.IP "\(bu" 2
\&\s-1RET:\s0 job information, with structure of \f(CW\*(C`job_info_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fI\f(CI$resp\fI = \f(CI$slurm\fI\->load_jobs($update_time=0, \f(CI$show_flags\fI=0);\fR
.IX Subsection "$resp = $slurm->load_jobs($update_time=0, $show_flags=0);"
.PP
Issue \s-1RPC\s0 to get all \s-1SLURM\s0 job information if changed.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$update_time:\fR time of current job information data.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$show_flags:\fR job filtering options.
.IP "\(bu" 2
\&\s-1RET:\s0 job information, with structure of \f(CW\*(C`job_info_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->notify_job($job_id, \f(CI$message\fI);\fR
.IX Subsection "$rc = $slurm->notify_job($job_id, $message);"
.PP
Send message to the job's stdout, usable only by user root.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR \s-1SLURM\s0 job id or 0 for all jobs.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$message:\fR arbitrary message.
.IP "\(bu" 2
\&\s-1RET: 0\s0 or \-1 on error.
.PP
\fI\f(CI$job_id\fI = \f(CI$slurm\fI\->pid2jobid($job_pid);\fR
.IX Subsection "$job_id = $slurm->pid2jobid($job_pid);"
.PP
Issue \s-1RPC\s0 to get the \s-1SLURM\s0 job \s-1ID\s0 of a given process \s-1ID\s0 on this machine.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_pid:\fR process \s-1ID\s0 of interest on this machine.
.IP "\(bu" 2
\&\s-1RET:\s0 corresponding job \s-1ID.\s0 On failure \f(CW\*(C`undef\*(C'\fR is returned.
.PP
\fI\f(CI$slurm\fI\->print_job_info($out, \f(CI$job_info\fI, \f(CI$one_liner\fI=0);\fR
.IX Subsection "$slurm->print_job_info($out, $job_info, $one_liner=0);"
.PP
Output information about a specific \s-1SLURM\s0 job based upon message as loaded using \f(CW\*(C`load_jobs()\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$out:\fR file to write to.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_info:\fR an individual job information record, with structure of \f(CW\*(C`job_info_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$one_liner:\fR print as a single line if true.
.PP
\fI\f(CI$slurm\fI\->print_job_info_msg($out, \f(CI$job_info_msg\fI, \f(CI$one_liner\fI=0);\fR
.IX Subsection "$slurm->print_job_info_msg($out, $job_info_msg, $one_liner=0);"
.PP
Output information about all \s-1SLURM\s0 jobs based upon message as loaded using \f(CW\*(C`load_jobs()\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$out:\fR file to write to.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_info_msg:\fR job information message, with structure of \f(CW\*(C`job_info_msg_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$one_liner:\fR print as a single line if true.
.PP
\fI\f(CI$str\fI = \f(CI$slurm\fI\->sprint_job_info($job_info, \f(CI$one_liner\fI=0);\fR
.IX Subsection "$str = $slurm->sprint_job_info($job_info, $one_liner=0);"
.PP
Output information about a specific \s-1SLURM\s0 job based upon message as loaded using \f(CW\*(C`load_jobs()\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_info:\fR an individual job information record, with structure of \f(CW\*(C`job_info_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$one_liner:\fR print as a single line if true.
.IP "\(bu" 2
\&\s-1RET:\s0 string containing formatted output.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->update_job($job_info);\fR
.IX Subsection "$rc = $slurm->update_job($job_info);"
.PP
Issue \s-1RPC\s0 to a job's configuration per request only usable by user root or (for some parameters) the job's owner.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_info:\fR description of job updates, with structure of \f(CW\*(C`job_desc_msg_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1RET: 0\s0 on success, otherwise return \-1 and set errno to indicate the error.
.SS "\s-1SLURM JOB STEP CONFIGURATION READ/PRINT/UPDATE FUNCTIONS\s0"
.IX Subsection "SLURM JOB STEP CONFIGURATION READ/PRINT/UPDATE FUNCTIONS"
\fI\f(CI$resp\fI = \f(CI$slurm\fI\->get_job_steps($update_time=0, \f(CI$job_id\fI=NO_VAL, \f(CI$step_id\fI=NO_VAL, \f(CI$show_flags\fI=0);\fR
.IX Subsection "$resp = $slurm->get_job_steps($update_time=0, $job_id=NO_VAL, $step_id=NO_VAL, $show_flags=0);"
.PP
Issue \s-1RPC\s0 to get specific slurm job step configuration information if changed since update_time.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$update_time:\fR time of current configuration data.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR get information for specific job id, \s-1NO_VAL\s0 for all jobs.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$step_id:\fR get information for specific job step id, \s-1NO_VAL\s0 for all job steps.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$show_flags:\fR job step filtering options.
.IP "\(bu" 2
\&\s-1RET:\s0 job step information, with structure of \f(CW\*(C`job_step_info_response_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fI\f(CI$slurm\fI\->print_job_step_info_msg($out, \f(CI$step_info_msg\fI, \f(CI$one_liner\fI);\fR
.IX Subsection "$slurm->print_job_step_info_msg($out, $step_info_msg, $one_liner);"
.PP
Output information about all \s-1SLURM\s0 job steps based upon message as loaded using \f(CW\*(C`get_job_steps()\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$out:\fR file to write to.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$step_info_msg:\fR job step information message, with structure of \f(CW\*(C`job_step_info_response_msg_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$one_liner:\fR print as a single line if true.
.PP
\fI\f(CI$slurm\fI\->print_job_step_info($out, \f(CI$step_info\fI, \f(CI$one_liner\fI);\fR
.IX Subsection "$slurm->print_job_step_info($out, $step_info, $one_liner);"
.PP
Output information about a specific \s-1SLURM\s0 job step based upon message as loaded using \f(CW\*(C`get_job_steps()\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$out:\fR file to write to.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$step_info:\fR job step information, with structure of \f(CW\*(C`job_step_info_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$one_liner:\fR print as a single line if true.
.PP
\fI\f(CI$str\fI = \f(CI$slurm\fI\->sprint_job_step_info($step_info, \f(CI$one_liner\fI);\fR
.IX Subsection "$str = $slurm->sprint_job_step_info($step_info, $one_liner);"
.PP
Output information about a specific \s-1SLURM\s0 job step based upon message as loaded using \f(CW\*(C`get_job_steps()\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$step_info:\fR job step information, with structure of \f(CW\*(C`job_step_info_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$one_liner:\fR print as a single line if true.
.IP "\(bu" 2
\&\s-1RET:\s0 string containing formatted output.
.PP
\fI\f(CI$layout\fI = \f(CI$slurm\fI\->job_step_layout_get($job_id, \f(CI$step_id\fI);\fR
.IX Subsection "$layout = $slurm->job_step_layout_get($job_id, $step_id);"
.PP
Get the layout structure for a particular job step.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR \s-1SLURM\s0 job \s-1ID.\s0
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$step_id:\fR \s-1SLURM\s0 step \s-1ID.\s0
.IP "\(bu" 2
\&\s-1RET:\s0 layout of the job step, with structure of \f(CW\*(C`slurm_step_layout_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fI\f(CI$resp\fI = \f(CI$slurm\fI\->job_step_stat($job_id, \f(CI$step_id\fI, \f(CI$nodelist\fI=undef);\fR
.IX Subsection "$resp = $slurm->job_step_stat($job_id, $step_id, $nodelist=undef);"
.PP
Get status of a current step.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id\fR : \s-1SLURM\s0 job \s-1ID.\s0
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$step_id:\fR \s-1SLURM\s0 step \s-1ID.\s0
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$nodelist:\fR nodes to check status of step. If omitted, all nodes in step are used.
.IP "\(bu" 2
\&\s-1RET:\s0 response of step status, with structure of \f(CW\*(C`job_step_stat_response_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned.
.PP
\fI\f(CI$resp\fI = \f(CI$slurm\fI\->job_step_get_pids($job_id, \f(CI$step_id\fI, \f(CI$nodelist\fI);\fR
.IX Subsection "$resp = $slurm->job_step_get_pids($job_id, $step_id, $nodelist);"
.PP
Get the complete list of pids for a given job step.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR \s-1SLURM\s0 job \s-1ID.\s0
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$step_id:\fR \s-1SLURM\s0 step \s-1ID.\s0
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$nodelist:\fR nodes to check pids of step. If omitted, all nodes in step are used.
.IP "\(bu" 2
\&\s-1RET:\s0 response of pids information, with structure of \f(CW\*(C`job_step_pids_response_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned.
.SS "\s-1SLURM NODE CONFIGURATION READ/PRINT/UPDATE FUNCTIONS\s0"
.IX Subsection "SLURM NODE CONFIGURATION READ/PRINT/UPDATE FUNCTIONS"
\fI\f(CI$resp\fI = \f(CI$slurm\fI\->load_node($update_time=0, \f(CI$show_flags\fI=0);\fR
.IX Subsection "$resp = $slurm->load_node($update_time=0, $show_flags=0);"
.PP
Issue \s-1RPC\s0 to get all node configuration information if changed.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$update_time:\fR time of current configuration data.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$show_flags:\fR node filtering options.
.IP "\(bu" 2
\&\s-1RET:\s0 response hash reference with structure of \f(CW\*(C`node_info_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fI\f(CI$slurm\fI\->print_node_info_msg($out, \f(CI$node_info_msg\fI, \f(CI$one_liner\fI=0);\fR
.IX Subsection "$slurm->print_node_info_msg($out, $node_info_msg, $one_liner=0);"
.PP
Output information about all \s-1SLURM\s0 nodes based upon message as loaded using \f(CW\*(C`load_node()\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$out:\fR \s-1FILE\s0 handle to write to.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$node_info_msg:\fR node information message to print, with structure of \f(CW\*(C`node_info_msg_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$one_liner:\fR if true, each node info will be printed as a single line.
.PP
\fI\f(CI$slurm\fI\->print_node_table($out, \f(CI$node_info\fI, \f(CI$one_liner\fI=0);\fR
.IX Subsection "$slurm->print_node_table($out, $node_info, $one_liner=0);"
.PP
Output information about a specific \s-1SLURM\s0 node based upon message as loaded using \f(CW\*(C`load_node()\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$out:\fR \s-1FILE\s0 handle to write to.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$node_info:\fR an individual node information record with structure of \f(CW\*(C`node_info_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$one_liner:\fR whether to print as a single line.
.PP
\fI\f(CI$str\fI = \f(CI$slurm\fI\->sprint_node_table($node_info, \f(CI$one_liner\fI=0);\fR
.IX Subsection "$str = $slurm->sprint_node_table($node_info, $one_liner=0);"
.PP
Output information about a specific \s-1SLURM\s0 node based upon message as loaded using \f(CW\*(C`load_node\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$node_info:\fR an individual node information record with structure of \f(CW\*(C`node_info_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$one_liner:\fR whether to print as a single line.
.IP "\(bu" 2
\&\s-1RET:\s0 string containing formatted output on success, \f(CW\*(C`undef\*(C'\fR on failure.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->update_node($node_info);\fR
.IX Subsection "$rc = $slurm->update_node($node_info);"
.PP
Issue \s-1RPC\s0 to modify a node's configuration per request, only usable by user root.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$node_info:\fR description of node updates, with structure of \f(CW\*(C`update_node_msg_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1RET: 0\s0 on success, \-1 on failure with errno set.
.SS "\s-1SLURM SWITCH TOPOLOGY CONFIGURATION READ/PRINT FUNCTIONS\s0"
.IX Subsection "SLURM SWITCH TOPOLOGY CONFIGURATION READ/PRINT FUNCTIONS"
\fI\f(CI$resp\fI = \f(CI$slurm\fI\->\fIload_topo()\fI;\fR
.IX Subsection "$resp = $slurm->load_topo();"
.PP
Issue \s-1RPC\s0 to get all switch topology configuration information.
.IP "\(bu" 2
\&\s-1RET:\s0 response hash reference with structure of \f(CW\*(C`topo_info_response_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fI\f(CI$slurm\fI\->print_topo_info_msg($out, \f(CI$topo_info_msg\fI, \f(CI$one_liner\fI=0);\fR
.IX Subsection "$slurm->print_topo_info_msg($out, $topo_info_msg, $one_liner=0);"
.PP
Output information about all switch topology configuration information based upon message as loaded using \f(CW\*(C`load_topo()\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$out:\fR \s-1FILE\s0 handle to write to.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$topo_info_msg:\fR swith topology information message, with structure of \f(CW\*(C`topo_info_response_msg_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$one_liner:\fR print as a single line if not zero.
.PP
\fI\f(CI$slurm\fI\->print_topo_record($out, \f(CI$topo_info\fI, \f(CI$one_liner\fI);\fR
.IX Subsection "$slurm->print_topo_record($out, $topo_info, $one_liner);"
.PP
Output information about a specific \s-1SLURM\s0 topology record based upon message as loaded using \f(CW\*(C`load_topo()\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$out:\fR \s-1FILE\s0 handle to write to.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$topo_info:\fR an individual switch information record, with structure of \f(CW\*(C`topo_info_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$one_liner:\fR print as a single line if not zero.
.SS "\s-1SLURM SELECT READ/PRINT/UPDATE FUNCTIONS\s0"
.IX Subsection "SLURM SELECT READ/PRINT/UPDATE FUNCTIONS"
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->get_select_nodeinfo($nodeinfo, \f(CI$data_type\fI, \f(CI$state\fI, \f(CI$data\fI);\fR
.IX Subsection "$rc = $slurm->get_select_nodeinfo($nodeinfo, $data_type, $state, $data);"
.PP
Get data from a select node credential.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$nodeinfo:\fR select node credential to get data from.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$data_type:\fR type of data to get.
.RS 2
.IP "\(bu" 2
\&\s-1TODO:\s0 enumerate data type and returned value.
.RE
.RS 2
.RE
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$state:\fR state of node query.
.IP "\(bu" 2
\&\s-1OUT\s0 \f(CW$data:\fR the data got.
.SS "\s-1SLURM PARTITION CONFIGURATION READ/PRINT/UPDATE FUNCTIONS\s0"
.IX Subsection "SLURM PARTITION CONFIGURATION READ/PRINT/UPDATE FUNCTIONS"
\fI\f(CI$resp\fI = \f(CI$slurm\fI\->load_partitions($update_time=0, \f(CI$show_flags\fI=0);\fR
.IX Subsection "$resp = $slurm->load_partitions($update_time=0, $show_flags=0);"
.PP
Issue \s-1RPC\s0 to get all \s-1SLURM\s0 partition configuration information if changed.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$update_time:\fR time of current configuration data.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$show_flags:\fR partitions filtering options.
.IP "\(bu" 2
\&\s-1RET:\s0 response hash reference with structure of \f(CW\*(C`partition_info_msg_t\*(C'\fR.
.PP
\fI\f(CI$slurm\fI\->print_partition_info_msg($out, \f(CI$part_info_msg\fI, \f(CI$one_liner\fI=0);\fR
.IX Subsection "$slurm->print_partition_info_msg($out, $part_info_msg, $one_liner=0);"
.PP
Output information about all \s-1SLURM\s0 partitions based upon message as loaded using \f(CW\*(C`load_partitions()\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$out:\fR \s-1FILE\s0 handle to write to.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$part_info_msg:\fR partitions information message, with structure of \f(CW\*(C`partition_info_msg_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$one_liner:\fR print as a single line if true.
.PP
\fI\f(CI$slurm\fI\->print_partition_info($out, \f(CI$part_info\fI, \f(CI$one_liner\fI=0);\fR
.IX Subsection "$slurm->print_partition_info($out, $part_info, $one_liner=0);"
.PP
Output information about a specific \s-1SLURM\s0 partition based upon message as loaded using \f(CW\*(C`load_partitions()\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$out:\fR \s-1FILE\s0 handle to write to.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$part_info:\fR an individual partition information record, with structure of \f(CW\*(C`partition_info_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$one_liner:\fR print as a single ine if true.
.PP
\fI\f(CI$str\fI = \f(CI$slurm\fI\->sprint_partition_info($part_info, \f(CI$one_liner\fI=0);\fR
.IX Subsection "$str = $slurm->sprint_partition_info($part_info, $one_liner=0);"
.PP
Output information about a specific \s-1SLURM\s0 partition based upon message as loaded using \f(CW\*(C`load_reservations()\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$part_info:\fR an individual partition information record, with structure of \f(CW\*(C`partition_info_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$one_liner:\fR print as a single line if true.
.IP "\(bu" 2
\&\s-1RET:\s0 string containing formatted output. On failure \f(CW\*(C`undef\*(C'\fR is returned.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->create_partition($part_info);\fR
.IX Subsection "$rc = $slurm->create_partition($part_info);"
.PP
Create a new partition, only usable by user root.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$part_info:\fR description of partition configuration with structure of \f(CW\*(C`update_part_msg_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1RET: 0\s0 on success, \-1 on failure with errno set.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->update_partition($part_info);\fR
.IX Subsection "$rc = $slurm->update_partition($part_info);"
.PP
Issue \s-1RPC\s0 to update a partition's configuration per request, only usable by user root.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$part_info:\fR description of partition updates with structure of \f(CW\*(C`update_part_msg_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1RET: 0\s0 on success, \-1 on failure with errno set.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->delete_partition($part_info)\fR
.IX Subsection "$rc = $slurm->delete_partition($part_info)"
.PP
Issue \s-1RPC\s0 to delete a partition, only usable by user root.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$part_info:\fR description of partition to delete, with structure of \f(CW\*(C`delete_part_msg_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1RET: 0\s0 on success, \-1 on failure with errno set.
.SS "\s-1SLURM RESERVATION CONFIGURATION READ/PRINT/UPDATE FUNCTIONS\s0"
.IX Subsection "SLURM RESERVATION CONFIGURATION READ/PRINT/UPDATE FUNCTIONS"
\fI\f(CI$name\fI = \f(CI$slurm\fI\->create_reservation($resv_info);\fR
.IX Subsection "$name = $slurm->create_reservation($resv_info);"
.PP
Create a new reservation, only usable by user root.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$resv_info:\fR description of reservation, with structure of \f(CW\*(C`resv_desc_msg_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1RET:\s0 name of reservation created. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->update_reservation($resv_info);\fR
.IX Subsection "$rc = $slurm->update_reservation($resv_info);"
.PP
Modify an existing reservation, only usable by user root.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$resv_info:\fR description of reservation, with structure of \f(CW\*(C`resv_desc_msg_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1RET:\s0 error code.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->delete_reservation($resv_info);\fR
.IX Subsection "$rc = $slurm->delete_reservation($resv_info);"
.PP
Issue \s-1RPC\s0 to delete a reservation, only usable by user root.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$resv_info:\fR description of reservation to delete, with structure of \f(CW\*(C`reservation_name_msg_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1RET:\s0 error code
.PP
\fI\f(CI$resp\fI = \f(CI$slurm\fI\->load_reservations($update_time=0);\fR
.IX Subsection "$resp = $slurm->load_reservations($update_time=0);"
.PP
Issue \s-1RPC\s0 to get all \s-1SLURM\s0 reservation configuration information if changed.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$update_time:\fR time of current configuration data.
.IP "\(bu" 2
\&\s-1RET:\s0 response of reservation information, with structure of \f(CW\*(C`reserve_info_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.PP
\fI\f(CI$slurm\fI\->print_reservation_info_msg($out, \f(CI$resv_info_msg\fI, \f(CI$one_liner\fI=0);\fR
.IX Subsection "$slurm->print_reservation_info_msg($out, $resv_info_msg, $one_liner=0);"
.PP
Output information about all \s-1SLURM\s0 reservations based upon message as loaded using \f(CW\*(C`load_reservation()\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$out:\fR \s-1FILE\s0 handle to write to.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$resv_info_msg:\fR reservation information message, with structure of \f(CW\*(C`reserve_info_msg_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$one_liner:\fR print as a single line if true.
.PP
\fI\f(CI$slurm\fI\->print_reservation_info($out, \f(CI$resv_info\fI, \f(CI$one_liner\fI=0);\fR
.IX Subsection "$slurm->print_reservation_info($out, $resv_info, $one_liner=0);"
.PP
Output information about a specific \s-1SLURM\s0 reservation based upon message as loaded using \f(CW\*(C`load_reservation()\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$out:\fR \s-1FILE\s0 handle to write to.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$resv_info:\fR an individual reservation information record, with structure of \f(CW\*(C`reserve_info_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$one_liner:\fR print as a single line if true.
.PP
\fI\f(CI$str\fI = \f(CI$slurm\fI\->sprint_reservation_info($resv_info, \f(CI$one_liner\fI=0);\fR
.IX Subsection "$str = $slurm->sprint_reservation_info($resv_info, $one_liner=0);"
.PP
Output information about a specific \s-1SLURM\s0 reservation based upon message as loaded using \f(CW\*(C`load_reservations()\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$resv_info:\fR an individual reservation information record, with structure of \f(CW\*(C`reserve_info_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$one_liner:\fR print as a single line if true.
.IP "\(bu" 2
\&\s-1RET:\s0 string containing formatted output. On failure \f(CW\*(C`undef\*(C'\fR is returned.
.SS "\s-1SLURM PING/RECONFIGURE/SHUTDOWN FUNCTIONS\s0"
.IX Subsection "SLURM PING/RECONFIGURE/SHUTDOWN FUNCTIONS"
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->ping($primary);\fR
.IX Subsection "$rc = $slurm->ping($primary);"
.PP
Issue \s-1RPC\s0 to ping Slurm controller (slurmctld).
.IP "\(bu" 2
\&\s-1IN\s0 primary: 1 for primary controller, 2 for secondary controller.
.IP "\(bu" 2
\&\s-1RET:\s0 error code.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->\fIreconfigure()\fI\fR
.IX Subsection "$rc = $slurm->reconfigure()"
.PP
Issue \s-1RPC\s0 to have Slurm controller (slurmctld) reload its configuration file.
.IP "\(bu" 2
\&\s-1RET:\s0 error code.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->shutdown($options);\fR
.IX Subsection "$rc = $slurm->shutdown($options);"
.PP
Issue \s-1RPC\s0 to have Slurm controller (slurmctld) cease operations, both the primary and backup controller are shutdown.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$options:\fR
.RS 2
.IP "\(bu" 4
0: all slurm daemons are shutdown.
.IP "\(bu" 4
1: slurmctld generates a core file.
.IP "\(bu" 4
2: only the slurmctld is shutdown (no core file).
.RE
.RS 2
.RE
.IP "\(bu" 2
\&\s-1RET:\s0 error code.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->\fItakeover()\fI;\fR
.IX Subsection "$rc = $slurm->takeover();"
.PP
Issue \s-1RPC\s0 to have Slurm backup controller take over the primary controller. \s-1REQUEST_CONTROL\s0 is sent by the backup to the primary controller to take control.
.IP "\(bu" 2
\&\s-1RET:\s0 error code.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->set_debug_level($debug_level)\fR
.IX Subsection "$rc = $slurm->set_debug_level($debug_level)"
.PP
Issue \s-1RPC\s0 to set slurm controller debug level.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$debug_level:\fR requested debug level.
.IP "\(bu" 2
\&\s-1RET: 0\s0 on success, \-1 on error with errno set.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->set_schedlog_level($schedlog_level);\fR
.IX Subsection "$rc = $slurm->set_schedlog_level($schedlog_level);"
.PP
Issue \s-1RPC\s0 to set slurm scheduler log level.
.IP "\(bu" 2
schedlog_level: requested scheduler log level.
.IP "\(bu" 2
\&\s-1RET: 0\s0 on success, \-1 on error with errno set.
.SS "\s-1SLURM JOB SUSPEND FUNCTIONS\s0"
.IX Subsection "SLURM JOB SUSPEND FUNCTIONS"
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->suspend($job_id);\fR
.IX Subsection "$rc = $slurm->suspend($job_id);"
.PP
Suspend execution of a job.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR job on which top perform operation.
.IP "\(bu" 2
\&\s-1RET:\s0 error code.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->resume($job_id);\fR
.IX Subsection "$rc = $slurm->resume($job_id);"
.PP
Resume execution of a previously suspended job.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR job on which to perform operation.
.IP "\(bu" 2
\&\s-1RET:\s0 error code.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->requeue($job_id);\fR
.IX Subsection "$rc = $slurm->requeue($job_id);"
.PP
Re-queue a batch job, if already running then terminate it first.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR job on which to perform operation.
.IP "\(bu" 2
\&\s-1RET:\s0 error code.
.SS "\s-1SLURM JOB CHECKPOINT FUNCTIONS\s0"
.IX Subsection "SLURM JOB CHECKPOINT FUNCTIONS"
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->checkpoint_able($job_id, \f(CI$step_id\fI, \f(CI$start_time\fI);\fR
.IX Subsection "$rc = $slurm->checkpoint_able($job_id, $step_id, $start_time);"
.PP
Determine if the specified job step can presently be checkpointed.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR job on which to perform operation.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$step_id:\fR job step on which to perform operation.
.IP "\(bu" 2
\&\s-1OUT\s0 \f(CW$start_time:\fR time at which checkpoint request was issued.
.IP "\(bu" 2
\&\s-1RET: 0 \s0(can be checkpoined) or a slurm error code.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->checkpoint_disable($job_id, \f(CI$step_id\fI);\fR
.IX Subsection "$rc = $slurm->checkpoint_disable($job_id, $step_id);"
.PP
Disable checkpoint requests for some job step.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR job on which to perform operation.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$step_id:\fR job step on which to perform operation.
.IP "\(bu" 2
\&\s-1RET:\s0 error code.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->checkpoint_enable($job_id, \f(CI$step_id\fI);\fR
.IX Subsection "$rc = $slurm->checkpoint_enable($job_id, $step_id);"
.PP
Enable checkpoint requests for some job step.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR job on which to perform operation.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$step_id:\fR job step on which to perform operation.
.IP "\(bu" 2
\&\s-1RET:\s0 error code.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->checkpoint_create($job_id, \f(CI$step_id\fI, \f(CI$max_wait\fI, \f(CI$image_dir\fI);\fR
.IX Subsection "$rc = $slurm->checkpoint_create($job_id, $step_id, $max_wait, $image_dir);"
.PP
Initiate a checkpoint requests for some job step. The job will continue execution after the checkpoint operation completes.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR job on which to perform operation.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$step_id:\fR job step on which to perform operation.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$max_wait:\fR maximum wait for operation to complete, in seconds.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$image_dir:\fR directory to store image files.
.IP "\(bu" 2
\&\s-1RET:\s0 error code.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->checkpoint_vacate($job_id, \f(CI$step_id\fI, \f(CI$max_wait\fI, \f(CI$image_dir\fI);\fR
.IX Subsection "$rc = $slurm->checkpoint_vacate($job_id, $step_id, $max_wait, $image_dir);"
.PP
Initiate a checkpoint requests for some job step. The job will terminate after the checkpoint operation completes.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR job on which to perform operation.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$step_id:\fR job step on which to perform operation.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$max_wait:\fR maximum wait for operation to complete, in seconds.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$image_dir:\fR directory to store image files.
.IP "\(bu" 2
\&\s-1RET:\s0 error code.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->checkpoint_restart($job_id, \f(CI$step_id\fI, \f(CI$stick\fI, \f(CI$image_dir\fI)\fR
.IX Subsection "$rc = $slurm->checkpoint_restart($job_id, $step_id, $stick, $image_dir)"
.PP
Restart execution of a checkpointed job step.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR job on which to perform operation.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$step_id:\fR job step on which to perform operation.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$stick:\fR if true, stick to nodes previously running on.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$image_dir:\fR directory to find checkpoint image files.
.IP "\(bu" 2
\&\s-1RET:\s0 error code.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->checkpoint_complete($job_id, \f(CI$step_id\fI, \f(CI$begin_time\fI, \f(CI$error_code\fI, \f(CI$error_msg\fI);\fR
.IX Subsection "$rc = $slurm->checkpoint_complete($job_id, $step_id, $begin_time, $error_code, $error_msg);"
.PP
Note the completion of a job step's checkpoint operation.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR job on which to perform operation.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$step_id:\fR job step on which to perform operation.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$begin_time:\fR time at which checkpoint began.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$error_code:\fR error code, highest value for all complete calls is preserved.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$error_msg:\fR error message, preserved for highest error_code.
.IP "\(bu" 2
\&\s-1RET:\s0 error code.
.PP
\fIcheckpoint_task_complete($job_id, \f(CI$step_id\fI, \f(CI$task_id\fI, \f(CI$begin_time\fI, \f(CI$error_code\fI, \f(CI$error_msg\fI);\fR
.IX Subsection "checkpoint_task_complete($job_id, $step_id, $task_id, $begin_time, $error_code, $error_msg);"
.PP
Note the completion of a task's checkpoint operation.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR job on which to perform operation.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$step_id:\fR job step on which to perform operation.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$task_id:\fR task which completed the operation.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$begin_time:\fR time at which checkpoint began.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$error_code:\fR error code, highest value for all complete calls is preserved.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$error_msg:\fR error message, preserved for highest error_code.
.IP "\(bu" 2
\&\s-1RET:\s0 error code.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->checkpoint_error($job_id, \f(CI$step_id\fI, \f(CI$error_code\fI, \f(CI$error_msg\fI);\fR
.IX Subsection "$rc = $slurm->checkpoint_error($job_id, $step_id, $error_code, $error_msg);"
.PP
Gather error information for the last checkpoint operation for some job step.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR job on which to perform operation.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$step_id:\fR job step on which to perform operation.
.IP "\(bu" 2
\&\s-1OUT\s0 \f(CW$error_code:\fR error number associated with the last checkpoint operation.
.IP "\(bu" 2
\&\s-1OUT\s0 \f(CW$error_msg:\fR error message associated with the last checkpoint operation.
.IP "\(bu" 2
\&\s-1RET:\s0 error code.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->checkpoint_tasks($job_id, \f(CI$step_id\fI, \f(CI$image_dir\fI, \f(CI$max_wait\fI, \f(CI$nodelist\fI);\fR
.IX Subsection "$rc = $slurm->checkpoint_tasks($job_id, $step_id, $image_dir, $max_wait, $nodelist);"
.PP
Send checkoint request to tasks of specified job step.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$job_id:\fR job on which to perform operation.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$step_id:\fR job step on which to perform operation.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$image_dir:\fR location to store checkpoint image files.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$max_wait:\fR seconds to wait for the operation to complete.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$nodelist:\fR nodes to send the request.
.IP "\(bu" 2
\&\s-1RET: 0\s0 on success, non-zero on failure with errno set.
.SS "\s-1SLURM TRIGGER FUNCTIONS\s0"
.IX Subsection "SLURM TRIGGER FUNCTIONS"
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->set_trigger($trigger_info);\fR
.IX Subsection "$rc = $slurm->set_trigger($trigger_info);"
.PP
Set an event trigger.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$trigger_info:\fR hash reference of specification of trigger to create, with structure of \f(CW\*(C`trigger_info_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1RET:\s0 error code.
.PP
\fI\f(CI$rc\fI = \f(CI$slurm\fI\->clear_trigger($trigger_info);\fR
.IX Subsection "$rc = $slurm->clear_trigger($trigger_info);"
.PP
Clear an existing event trigger.
.IP "\(bu" 2
\&\s-1IN\s0 \f(CW$trigger_info:\fR hash reference of specification of trigger to remove, with structure of \f(CW\*(C`trigger_info_t\*(C'\fR.
.IP "\(bu" 2
\&\s-1RET:\s0 error code.
.PP
\fI\f(CI$resp\fI = \f(CI$slurm\fI\->\fIget_triggers()\fI;\fR
.IX Subsection "$resp = $slurm->get_triggers();"
.PP
Get all event trigger information.
.IP "\(bu" 2
\&\s-1RET:\s0 hash reference with structure of \f(CW\*(C`trigger_info_msg_t\*(C'\fR. On failure \f(CW\*(C`undef\*(C'\fR is returned with errno set.
.SS "\s-1JOB/NODE STATE TESTING FUNCTIONS\s0"
.IX Subsection "JOB/NODE STATE TESTING FUNCTIONS"
The following are functions to test job/node state, based on the macros defined in \fIsrc/common/slurm_protocol_defs.h\fR. The functions take a parameter of a hash reference of a job/node, and return a boolean value. For job, \f(CW$job\fR\->{job_state} is tested. For node, \f(CW$node\fR\->{node_state} is tested.
.PP
\fI\f(CI$cond\fI = \s-1IS_JOB_PENDING\s0($job);\fR
.IX Subsection "$cond = IS_JOB_PENDING($job);"
.PP
\fI\f(CI$cond\fI = \s-1IS_JOB_RUNNING\s0($job);\fR
.IX Subsection "$cond = IS_JOB_RUNNING($job);"
.PP
\fI\f(CI$cond\fI = \s-1IS_JOB_SUSPENDED\s0($job);\fR
.IX Subsection "$cond = IS_JOB_SUSPENDED($job);"
.PP
\fI\f(CI$cond\fI = \s-1IS_JOB_COMPLETE\s0($job);\fR
.IX Subsection "$cond = IS_JOB_COMPLETE($job);"
.PP
\fI\f(CI$cond\fI = \s-1IS_JOB_CANCELLED\s0($job);\fR
.IX Subsection "$cond = IS_JOB_CANCELLED($job);"
.PP
\fI\f(CI$cond\fI = \s-1IS_JOB_FAILED\s0($job);\fR
.IX Subsection "$cond = IS_JOB_FAILED($job);"
.PP
\fI\f(CI$cond\fI = \s-1IS_JOB_TIMEOUT\s0($job);\fR
.IX Subsection "$cond = IS_JOB_TIMEOUT($job);"
.PP
\fI\f(CI$cond\fI = \s-1IS_JOB_NODE_FAILED\s0($job);\fR
.IX Subsection "$cond = IS_JOB_NODE_FAILED($job);"
.PP
\fI\f(CI$cond\fI = \s-1IS_JOB_COMPLETING\s0($job);\fR
.IX Subsection "$cond = IS_JOB_COMPLETING($job);"
.PP
\fI\f(CI$cond\fI = \s-1IS_JOB_CONFIGURING\s0($job);\fR
.IX Subsection "$cond = IS_JOB_CONFIGURING($job);"
.PP
\fI\f(CI$cond\fI = \s-1IS_JOB_STARTED\s0($job);\fR
.IX Subsection "$cond = IS_JOB_STARTED($job);"
.PP
\fI\f(CI$cond\fI = \s-1IS_JOB_FINISHED\s0($job);\fR
.IX Subsection "$cond = IS_JOB_FINISHED($job);"
.PP
\fI\f(CI$cond\fI = \s-1IS_JOB_COMPLETED\s0($job);\fR
.IX Subsection "$cond = IS_JOB_COMPLETED($job);"
.PP
\fI\f(CI$cond\fI = \s-1IS_JOB_RESIZING\s0($job);\fR
.IX Subsection "$cond = IS_JOB_RESIZING($job);"
.PP
\fI\f(CI$cond\fI = \s-1IS_NODE_UNKNOWN\s0($node);\fR
.IX Subsection "$cond = IS_NODE_UNKNOWN($node);"
.PP
\fI\f(CI$cond\fI = \s-1IS_NODE_DOWN\s0($node);\fR
.IX Subsection "$cond = IS_NODE_DOWN($node);"
.PP
\fI\f(CI$cond\fI = \s-1IS_NODE_IDLE\s0($node);\fR
.IX Subsection "$cond = IS_NODE_IDLE($node);"
.PP
\fI\f(CI$cond\fI = \s-1IS_NODE_ALLOCATED\s0($node);\fR
.IX Subsection "$cond = IS_NODE_ALLOCATED($node);"
.PP
\fI\f(CI$cond\fI = \s-1IS_NODE_ERROR\s0($node);\fR
.IX Subsection "$cond = IS_NODE_ERROR($node);"
.PP
\fI\f(CI$cond\fI = \s-1IS_NODE_MIXED\s0($node);\fR
.IX Subsection "$cond = IS_NODE_MIXED($node);"
.PP
\fI\f(CI$cond\fI = \s-1IS_NODE_FUTURE\s0($node);\fR
.IX Subsection "$cond = IS_NODE_FUTURE($node);"
.PP
\fI\f(CI$cond\fI = \s-1IS_NODE_DRAIN\s0($node);\fR
.IX Subsection "$cond = IS_NODE_DRAIN($node);"
.PP
\fI\f(CI$cond\fI = \s-1IS_NODE_DRAINING\s0($node);\fR
.IX Subsection "$cond = IS_NODE_DRAINING($node);"
.PP
\fI\f(CI$cond\fI = \s-1IS_NODE_DRAINED\s0($node);\fR
.IX Subsection "$cond = IS_NODE_DRAINED($node);"
.PP
\fI\f(CI$cond\fI = \s-1IS_NODE_COMPLETING\s0($node);\fR
.IX Subsection "$cond = IS_NODE_COMPLETING($node);"
.PP
\fI\f(CI$cond\fI = \s-1IS_NODE_NO_RESPOND\s0($node);\fR
.IX Subsection "$cond = IS_NODE_NO_RESPOND($node);"
.PP
\fI\f(CI$cond\fI = \s-1IS_NODE_POWER_SAVE\s0($node);\fR
.IX Subsection "$cond = IS_NODE_POWER_SAVE($node);"
.PP
\fI\f(CI$cond\fI = \s-1IS_NODE_POWER_UP\s0($node);\fR
.IX Subsection "$cond = IS_NODE_POWER_UP($node);"
.PP
\fI\f(CI$cond\fI = \s-1IS_NODE_FAIL\s0($node);\fR
.IX Subsection "$cond = IS_NODE_FAIL($node);"
.PP
\fI\f(CI$cond\fI = \s-1IS_NODE_MAINT\s0($node);\fR
.IX Subsection "$cond = IS_NODE_MAINT($node);"
.SH "EXPORT"
.IX Header "EXPORT"
The job/node state testing functions are exported by default.
.PP
If ':constant' if specified, all constants are exported.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Slurm::Constant, Slurm::Hostlist, Slurm::Stepctx, Slurm::Bitstr
.PP
<slurm/slurm.h> for various hash reference structures.
.PP
Home page of \s-1SLURM: \s0<http://www.llnl.gov/linux/slurm/>.
.SH "AUTHOR"
.IX Header "AUTHOR"
This library is created by Hongjia Cao, <hjcao(\s-1AT\s0)nudt.edu.cn> and Danny Auble, <da(\s-1AT\s0)llnl.gov>. It is distributed with \s-1SLURM.\s0
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.4 or,
at your option, any later version of Perl 5 you may have available.
