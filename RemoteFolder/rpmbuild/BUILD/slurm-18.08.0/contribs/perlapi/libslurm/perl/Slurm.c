/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.18 from the
 * contents of Slurm.xs. Do not edit this file, edit Slurm.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Slurm.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#define NEED_newRV_noinc_GLOBAL
#include "ppport.h"

#include <slurm/slurm.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>

#include "slurm-perl.h"
#include "bitstr.h"

extern void slurm_conf_reinit(char *pathname);

/* Custom typemap that free's memory after copying to perl stack. */
typedef char char_xfree;
typedef char char_free;

struct slurm {
};
typedef struct slurm * slurm_t;

/*
 * default slurm object, for backward compatibility with "Slurm->method()".
 */
static struct slurm default_slurm_object;

static slurm_t
new_slurm(void)
{
	int size = sizeof(struct slurm);
	if (size == 0) {
		/* Avoid returning NULL, which causes the perl APIs to fail */
		size = 1;
	}
	return xmalloc(size);
}

static void
free_slurm(slurm_t self)
{
	xfree(self);
}



/********************************************************************/

#line 61 "Slurm.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 203 "Slurm.c"

XS_EUPXS(XS_Slurm_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_new)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "conf_file=NULL");
    {
	slurm_t	RETVAL;
	char *	conf_file;

	if (items < 1)
	    conf_file = NULL;
	else {
	    conf_file = (char *)SvPV_nolen(ST(0))
;
	}
#line 64 "Slurm.xs"
		if(conf_file) {
			slurm_conf_reinit(conf_file);
		}
		RETVAL = new_slurm();
		if (RETVAL == NULL) {
			XSRETURN_UNDEF;
		}
#line 229 "Slurm.c"
	ST(0) = sv_newmortal();
        sv_setref_pv( ST(0), "Slurm", (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	slurm_t	self;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_DESTROY() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 77 "Slurm.xs"
		if (self != &default_slurm_object) {
			free_slurm(self);
		}
#line 259 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_get_errno); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_get_errno)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_get_errno() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 89 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 291 "Slurm.c"

	RETVAL = slurm_get_errno();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_strerror); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_strerror)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "self, errnum=0");
    {
	char *	RETVAL;
	dXSTARG;
	slurm_t	self;
	int	errnum;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_strerror() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 2)
	    errnum = 0;
	else {
	    errnum = (int)SvIV(ST(1))
;
	}
#line 98 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (errnum == 0)
			errnum = slurm_get_errno();
		RETVAL = slurm_strerror(errnum);
#line 337 "Slurm.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_preempt_mode_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_preempt_mode_string)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, preempt_mode");
    {
	char *	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint16_t	preempt_mode = (unsigned short)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_preempt_mode_string() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 119 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		RETVAL = slurm_preempt_mode_string(preempt_mode);
#line 373 "Slurm.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_preempt_mode_num); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_preempt_mode_num)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, preempt_mode");
    {
	uint16_t	RETVAL;
	dXSTARG;
	slurm_t	self;
	char *	preempt_mode = (char *)SvPV_nolen(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_preempt_mode_num() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 133 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 408 "Slurm.c"

	RETVAL = slurm_preempt_mode_num(preempt_mode);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_job_reason_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_job_reason_string)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, inx");
    {
	char *	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	inx = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_job_reason_string() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 142 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		RETVAL = slurm_job_reason_string(inx);
#line 446 "Slurm.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_job_state_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_job_state_string)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, inx");
    {
	char *	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	inx = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_job_state_string() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 154 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		RETVAL = slurm_job_state_string(inx);
#line 482 "Slurm.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_job_state_string_compact); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_job_state_string_compact)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, inx");
    {
	char *	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	inx = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_job_state_string_compact() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 166 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		RETVAL = slurm_job_state_string_compact(inx);
#line 518 "Slurm.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_job_state_num); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_job_state_num)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, state_name");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	char *	state_name = (char *)SvPV_nolen(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_job_state_num() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 180 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 553 "Slurm.c"

	RETVAL = slurm_job_state_num(state_name);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_reservation_flags_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_reservation_flags_string)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, flags");
    {
	char_xfree *	RETVAL;
	slurm_t	self;
	uint16_t	flags = (unsigned short)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_reservation_flags_string() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 189 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		RETVAL = slurm_reservation_flags_string(flags);
#line 590 "Slurm.c"
	ST(0) = sv_newmortal();
	sv_setpv ((SV*)ST(0), RETVAL);
        xfree (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_node_state_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_node_state_string)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, inx");
    {
	char *	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	inx = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_node_state_string() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 201 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		RETVAL = slurm_node_state_string(inx);
#line 628 "Slurm.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_node_state_string_compact); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_node_state_string_compact)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, inx");
    {
	char *	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	inx = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_node_state_string_compact() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 213 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		RETVAL = slurm_node_state_string_compact(inx);
#line 664 "Slurm.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_private_data_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_private_data_string)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, private_data");
    {
#line 225 "Slurm.xs"
		char tmp_str[128];
#line 680 "Slurm.c"
	char *	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint16_t	private_data = (unsigned short)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_private_data_string() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 227 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		slurm_private_data_string(private_data, tmp_str, sizeof(tmp_str));
		RETVAL = tmp_str;
#line 704 "Slurm.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_accounting_enforce_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_accounting_enforce_string)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, enforce");
    {
#line 240 "Slurm.xs"
		char tmp_str[128];
#line 720 "Slurm.c"
	char *	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint16_t	enforce = (unsigned short)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_accounting_enforce_string() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 242 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		slurm_accounting_enforce_string(enforce, tmp_str, sizeof(tmp_str));
		RETVAL = tmp_str;
#line 744 "Slurm.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_node_use_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_node_use_string)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, node_use");
    {
	char *	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint16_t	node_use = (unsigned short)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_node_use_string() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 255 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		RETVAL = slurm_node_use_string((enum node_use_type)node_use);
#line 780 "Slurm.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_allocate_resources); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_allocate_resources)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, job_desc");
    {
#line 273 "Slurm.xs"
		job_desc_msg_t jd_msg;
		resource_allocation_response_msg_t* resp_msg = NULL;
		int rc;
#line 798 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	HV *	job_desc;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_allocate_resources() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    job_desc = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::allocate_resources",
				"job_desc");
		}
	} STMT_END
;
#line 277 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (hv_to_job_desc_msg(job_desc, &jd_msg) < 0) {
			XSRETURN_UNDEF;
		}
		rc = slurm_allocate_resources(&jd_msg, &resp_msg);
		free_job_desc_msg_memory(&jd_msg);
		if (resp_msg == NULL) {
			XSRETURN_UNDEF;
		}
		if(rc != SLURM_SUCCESS) {
			slurm_free_resource_allocation_response_msg(resp_msg);
			XSRETURN_UNDEF;
		}
		RETVAL = newHV();
		sv_2mortal((SV*)RETVAL);
		rc = resource_allocation_response_msg_to_hv(resp_msg, RETVAL);
		slurm_free_resource_allocation_response_msg(resp_msg);
		if (rc < 0) {
			XSRETURN_UNDEF;
		}
#line 851 "Slurm.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_allocate_resources_blocking); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_allocate_resources_blocking)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 4)
       croak_xs_usage(cv,  "self, user_req, timeout=0, pending_callback=NULL");
    {
#line 307 "Slurm.xs"
		job_desc_msg_t jd_msg;
		resource_allocation_response_msg_t *resp_msg = NULL;
#line 869 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	HV *	user_req;
	time_t	timeout;
	SV *	pending_callback;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_allocate_resources_blocking() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    user_req = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::allocate_resources_blocking",
				"user_req");
		}
	} STMT_END
;

	if (items < 3)
	    timeout = 0;
	else {
	    timeout = (time_t)SvNV(ST(2))
;
	}

	if (items < 4)
	    pending_callback = NULL;
	else {
	    pending_callback = ST(3)
;
	}
#line 310 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (hv_to_job_desc_msg(user_req, &jd_msg) < 0) {
			XSRETURN_UNDEF;
		}
		set_sarb_cb(pending_callback);
		resp_msg = slurm_allocate_resources_blocking(&jd_msg, timeout,
				pending_callback == NULL ? NULL : sarb_cb);
		free_job_desc_msg_memory(&jd_msg);
		if (resp_msg != NULL) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			resource_allocation_response_msg_to_hv(resp_msg, RETVAL);
			slurm_free_resource_allocation_response_msg(resp_msg);
		}
		else {
			XSRETURN_UNDEF;
		}
#line 935 "Slurm.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_allocation_lookup); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_allocation_lookup)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, job_id");
    {
#line 338 "Slurm.xs"
		resource_allocation_response_msg_t *resp_msg = NULL;
		int rc;
#line 953 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_allocation_lookup() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 341 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_allocation_lookup(job_id, &resp_msg);
		if(rc != SLURM_SUCCESS) {
			slurm_free_resource_allocation_response_msg(resp_msg);
			XSRETURN_UNDEF;
		}
		RETVAL = newHV();
		sv_2mortal((SV*)RETVAL);
		rc = resource_allocation_response_msg_to_hv(resp_msg, RETVAL);
		slurm_free_resource_allocation_response_msg(resp_msg);
		if (rc < 0) {
			XSRETURN_UNDEF;
		}
#line 986 "Slurm.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_read_hostfile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_read_hostfile)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, filename, n");
    {
	char_free *	RETVAL;
	slurm_t	self;
	char *	filename = (char *)SvPV_nolen(ST(1))
;
	int	n = (int)SvIV(ST(2))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_read_hostfile() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 364 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		RETVAL = slurm_read_hostfile(filename, n);
		if(RETVAL == NULL) {
			XSRETURN_UNDEF;
		}
#line 1027 "Slurm.c"
	ST(0) = sv_newmortal();
	sv_setpv ((SV*)ST(0), RETVAL);
        free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_allocation_msg_thr_create); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_allocation_msg_thr_create)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, port, callbacks");
    {
	allocation_msg_thread_t *	RETVAL;
	slurm_t	self;
	uint16_t	port;
	HV *	callbacks;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_allocation_msg_thr_create() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    callbacks = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::allocation_msg_thr_create",
				"callbacks");
		}
	} STMT_END
;
#line 379 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		set_sacb(callbacks);
#line 1078 "Slurm.c"

	RETVAL = slurm_allocation_msg_thr_create(&port, &sacb);
	sv_setuv(ST(1), (UV)port);
	SvSETMAGIC(ST(1));
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), "Slurm::allocation_msg_thread_t", (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_allocation_msg_thr_destroy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_allocation_msg_thr_destroy)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, msg_thr");
    {
	slurm_t	self;
	allocation_msg_thread_t *	msg_thr;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_allocation_msg_thr_destroy() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) && sv_derived_from(ST(1), "Slurm::allocation_msg_thread_t")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		msg_thr = INT2PTR(allocation_msg_thread_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::allocation_msg_thr_destroy",
			"msg_thr", "Slurm::allocation_msg_thread_t");
	}
;
#line 391 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */

#line 1126 "Slurm.c"

	slurm_allocation_msg_thr_destroy(msg_thr);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_submit_batch_job); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_submit_batch_job)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, job_desc");
    {
#line 403 "Slurm.xs"
		job_desc_msg_t jd_msg;
		submit_response_msg_t *resp_msg = NULL;
		int rc;
#line 1145 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	HV *	job_desc;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_submit_batch_job() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    job_desc = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::submit_batch_job",
				"job_desc");
		}
	} STMT_END
;
#line 407 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_job_desc_msg(job_desc, &jd_msg) < 0) {
			XSRETURN_UNDEF;
		}
		rc = slurm_submit_batch_job(&jd_msg, &resp_msg);
		free_job_desc_msg_memory(&jd_msg);
		if(rc != SLURM_SUCCESS) {
			slurm_free_submit_response_response_msg(resp_msg);
			XSRETURN_UNDEF;
		}
		RETVAL = newHV();
		sv_2mortal((SV*)RETVAL);
		rc = submit_response_msg_to_hv(resp_msg, RETVAL);
		slurm_free_submit_response_response_msg(resp_msg);
		if (rc < 0) {
			XSRETURN_UNDEF;
		}
#line 1195 "Slurm.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_job_will_run); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_job_will_run)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, job_desc");
    {
#line 434 "Slurm.xs"
		job_desc_msg_t jd_msg;
#line 1212 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	job_desc;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_job_will_run() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    job_desc = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::job_will_run",
				"job_desc");
		}
	} STMT_END
;
#line 436 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (hv_to_job_desc_msg(job_desc, &jd_msg) < 0) {
			XSRETURN_UNDEF;
		}
		RETVAL = slurm_job_will_run(&jd_msg);
		free_job_desc_msg_memory(&jd_msg);
#line 1252 "Slurm.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_sbcast_lookup); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_sbcast_lookup)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, job_id, step_id");
    {
#line 452 "Slurm.xs"
		job_sbcast_cred_msg_t *info;
		int rc;
		uint32_t pack_job_offset = NO_VAL;
#line 1270 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	step_id = (unsigned long)SvUV(ST(2))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_sbcast_lookup() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 456 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_sbcast_lookup(job_id, pack_job_offset, step_id,
					 &info);
		if (rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = job_sbcast_cred_msg_to_hv(info, RETVAL);
			slurm_free_sbcast_cred_msg(info);
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 1306 "Slurm.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_kill_job); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_kill_job)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, job_id, signal, batch_flag=0");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint16_t	signal = (unsigned short)SvUV(ST(2))
;
	uint16_t	batch_flag;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_kill_job() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 4)
	    batch_flag = 0;
	else {
	    batch_flag = (unsigned short)SvUV(ST(3))
;
	}
#line 484 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 1352 "Slurm.c"

	RETVAL = slurm_kill_job(job_id, signal, batch_flag);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_kill_job_step); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_kill_job_step)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "self, job_id, step_id, signal");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	step_id = (unsigned long)SvUV(ST(2))
;
	uint16_t	signal = (unsigned short)SvUV(ST(3))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_kill_job_step() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 495 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 1393 "Slurm.c"

	RETVAL = slurm_kill_job_step(job_id, step_id, signal);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_signal_job); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_signal_job)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, job_id, signal");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint16_t	signal = (unsigned short)SvUV(ST(2))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_signal_job() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 506 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 1432 "Slurm.c"

	RETVAL = slurm_signal_job(job_id, signal);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_signal_job_step); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_signal_job_step)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "self, job_id, step_id, signal");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	step_id = (unsigned long)SvUV(ST(2))
;
	uint16_t	signal = (unsigned short)SvUV(ST(3))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_signal_job_step() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 517 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 1473 "Slurm.c"

	RETVAL = slurm_signal_job_step(job_id, step_id, signal);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_complete_job); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_complete_job)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "self, job_id, job_rc=0");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	job_rc;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_complete_job() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 3)
	    job_rc = 0;
	else {
	    job_rc = (unsigned long)SvUV(ST(2))
;
	}
#line 532 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 1518 "Slurm.c"

	RETVAL = slurm_complete_job(job_id, job_rc);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_terminate_job_step); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_terminate_job_step)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, job_id, step_id");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	step_id = (unsigned long)SvUV(ST(2))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_terminate_job_step() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 543 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 1557 "Slurm.c"

	RETVAL = slurm_terminate_job_step(job_id, step_id);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_step_ctx_create); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_step_ctx_create)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, step_params");
    {
#line 561 "Slurm.xs"
		slurm_step_ctx_params_t sp;
#line 1575 "Slurm.c"
	slurm_step_ctx_t *	RETVAL;
	slurm_t	self;
	HV *	step_params;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_step_ctx_create() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    step_params = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::step_ctx_create",
				"step_params");
		}
	} STMT_END
;
#line 563 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (hv_to_slurm_step_ctx_params(step_params, &sp) < 0) {
			XSRETURN_UNDEF;
		}
		RETVAL = slurm_step_ctx_create(&sp);
		if (RETVAL == NULL) {
			XSRETURN_UNDEF;
		}
#line 1616 "Slurm.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), "Slurm::Stepctx", (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_step_ctx_create_no_alloc); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_step_ctx_create_no_alloc)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, step_params, step_id");
    {
#line 581 "Slurm.xs"
		slurm_step_ctx_params_t sp;
#line 1633 "Slurm.c"
	slurm_step_ctx_t *	RETVAL;
	slurm_t	self;
	HV *	step_params;
	uint32_t	step_id = (unsigned long)SvUV(ST(2))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_step_ctx_create_no_alloc() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    step_params = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::step_ctx_create_no_alloc",
				"step_params");
		}
	} STMT_END
;
#line 583 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (hv_to_slurm_step_ctx_params(step_params, &sp) < 0) {
			XSRETURN_UNDEF;
		}
		RETVAL = slurm_step_ctx_create_no_alloc(&sp, step_id);
		if (RETVAL == NULL) {
			XSRETURN_UNDEF;
		}
#line 1676 "Slurm.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), "Slurm::Stepctx", (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Stepctx_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Stepctx_get)
{
    dVAR; dXSARGS;
    if (items < 3)
       croak_xs_usage(cv,  "ctx, ctx_key, INOUT ");
    {
#line 603 "Slurm.xs"
		uint32_t tmp_32, *tmp_32_ptr;
		uint16_t tmp_16, *tmp_16_ptr;
#if 0
		/* TODO: job_step_create_response_msg_t not exported in slurm.h */
		job_step_create_response_msg_t *resp_msg;
#endif
		slurm_cred_t *cred;
		dynamic_plugin_data_t *switch_info;
		char *tmp_str;
		int i, tmp_int, *tmp_int_ptr;
#line 1702 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_step_ctx_t *	ctx;
	int	ctx_key = (int)SvIV(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Stepctx")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		ctx = INT2PTR(slurm_step_ctx_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Stepctx::get",
			"ctx", "Slurm::Stepctx");
	}
;
#line 614 "Slurm.xs"
		switch(ctx_key) {
		case SLURM_STEP_CTX_JOBID: /* uint32_t* */
		case SLURM_STEP_CTX_STEPID: /* uint32_t* */
		case SLURM_STEP_CTX_NUM_HOSTS: /* uint32_t* */
			if (items != 3) {
				Perl_warn( aTHX_ "error number of parameters");
				errno = EINVAL;
				RETVAL = SLURM_ERROR;
				break;
			}
			RETVAL = slurm_step_ctx_get(ctx, ctx_key, &tmp_32);
			if (RETVAL == SLURM_SUCCESS) {
				sv_setuv(ST(2), (UV)tmp_32);
			}
			break;
		case SLURM_STEP_CTX_TASKS: /* uint16_t** */
			if (items != 3) {
				Perl_warn( aTHX_ "error number of parameters");
				errno = EINVAL;
				RETVAL = SLURM_ERROR;
				break;
			}
			RETVAL = slurm_step_ctx_get(ctx, SLURM_STEP_CTX_NUM_HOSTS, &tmp_32);
			if (RETVAL != SLURM_SUCCESS)
				break;
			RETVAL = slurm_step_ctx_get(ctx, ctx_key, &tmp_16_ptr);
			if (RETVAL == SLURM_SUCCESS) {
				AV* av = newAV();
				for(i = 0; i < tmp_32; i ++) {
					av_store_uint16_t(av, i, tmp_16_ptr[i]);
				}
				sv_setsv(ST(2), newRV_noinc((SV*)av));
			}
			break;
		case SLURM_STEP_CTX_TID: /* uint32_t, uint32_t** */
			if (items != 4) {
				Perl_warn( aTHX_ "error number of parameters");
				errno = EINVAL;
				RETVAL = SLURM_ERROR;
				break;
			}
			tmp_32 = (uint32_t)SvUV(ST(2));
			RETVAL = slurm_step_ctx_get(ctx, SLURM_STEP_CTX_TASKS, &tmp_16_ptr);
			if (RETVAL != SLURM_SUCCESS)
				break;
			tmp_16 = tmp_16_ptr[tmp_32];
			RETVAL = slurm_step_ctx_get(ctx, ctx_key, tmp_32, &tmp_32_ptr);
			if (RETVAL == SLURM_SUCCESS) {
				AV* av = newAV();
				for(i = 0; i < tmp_16; i ++) {
					av_store_uint32_t(av, i, tmp_32_ptr[i]);
				}
				sv_setsv(ST(3), newRV_noinc((SV*)av));
			}
			break;
#if 0
		case SLURM_STEP_CTX_RESP: /* job_step_create_response_msg_t** */
			if (items != 3) {
				Perl_warn( aTHX_ "error number of parameters");
				errno = EINVAL;
				RETVAL = SLURM_ERROR;
				break;
			}
			RETVAL = slurm_step_ctx_get(ctx, ctx_key, &resp_msg);
			if (RETVAL == SLURM_SUCCESS) {
				HV *hv = newHV();
				if (job_step_create_response_msg_to_hv(resp_msg, hv) < 0) {
					SVdev_REFCNT((SV*)hv);
					RETVAL = SLURM_ERROR;
					break;
				}
				sv_setsv(ST(2), newRV_noinc((SV*)hv));
			}
			break;
#endif
		case SLURM_STEP_CTX_CRED: /* slurm_cred_t** */
			if (items != 3) {
				Perl_warn( aTHX_ "error number of parameters");
				errno = EINVAL;
				RETVAL = SLURM_ERROR;
				break;
			}
			RETVAL = slurm_step_ctx_get(ctx, ctx_key, &cred);
			if (RETVAL == SLURM_SUCCESS && cred) {
				sv_setref_pv(ST(2), "Slurm::slurm_cred_t", (void*)cred);
			} else if (RETVAL == SLURM_SUCCESS) {
				/* the returned cred is NULL */
				sv_setsv(ST(2), &PL_sv_undef);
			}
			break;
		case SLURM_STEP_CTX_SWITCH_JOB: /* switch_jobinfo_t** */
			if (items != 3) {
				Perl_warn( aTHX_ "error number of parameters");
				errno = EINVAL;
				RETVAL = SLURM_ERROR;
				break;
			}
			RETVAL = slurm_step_ctx_get(ctx, ctx_key, &switch_info);
			if (RETVAL == SLURM_SUCCESS && switch_info) {
				sv_setref_pv(ST(2), "Slurm::dynamic_plugin_data_t", (void*)switch_info);
			} else if (RETVAL == SLURM_SUCCESS) {
				/* the returned switch_info is NULL */
				sv_setsv(ST(2), &PL_sv_undef);
			}
			break;
		case SLURM_STEP_CTX_HOST: /* uint32_t, char** */
			if (items != 4) {
				Perl_warn( aTHX_ "error number of parameters");
				errno = EINVAL;
				RETVAL = SLURM_ERROR;
				break;
			}
			tmp_32 = (uint32_t)SvUV(ST(2));
			RETVAL = slurm_step_ctx_get(ctx, ctx_key, tmp_32, &tmp_str);
			if (RETVAL == SLURM_SUCCESS) {
				sv_setpv(ST(3), tmp_str);
			}
			break;
		case SLURM_STEP_CTX_USER_MANAGED_SOCKETS: /* int*, int** */
			if (items != 4) {
				Perl_warn( aTHX_ "error number of parameters");
				errno = EINVAL;
				RETVAL = SLURM_ERROR;
				break;
			}
			RETVAL = slurm_step_ctx_get(ctx, ctx_key, &tmp_int, &tmp_int_ptr);
			if (RETVAL == SLURM_SUCCESS) {
				AV *av = newAV();
				for (i = 0; i < tmp_int; i ++) {
					av_store_int(av, i, tmp_int_ptr[i]);
				}
				sv_setiv(ST(2), tmp_int);
				sv_setsv(ST(3), newRV_noinc((SV*)av));
			} else { /* returned val: 0, NULL */
				sv_setiv(ST(2), tmp_int);
				sv_setsv(ST(3), &PL_sv_undef);
			}
			break;
		default:
			RETVAL = slurm_step_ctx_get(ctx, ctx_key);
		}
#line 1860 "Slurm.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Stepctx_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Stepctx_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	slurm_step_ctx_t *	ctx;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Stepctx")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		ctx = INT2PTR(slurm_step_ctx_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Stepctx::DESTROY",
			"ctx", "Slurm::Stepctx");
	}
;
#line 765 "Slurm.xs"
		slurm_step_ctx_destroy(ctx);
#line 1887 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Stepctx_daemon_per_node_hack); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Stepctx_daemon_per_node_hack)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "ctx, node_list, node_cnt, curr_task_num");
    {
#line 770 "Slurm.xs"
	        uint32_t *tmp32;
#line 1902 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_step_ctx_t *	ctx;
	char *	node_list = (char *)SvPV_nolen(ST(1))
;
	uint32_t	node_cnt = (unsigned long)SvUV(ST(2))
;
	void *	curr_task_num = INT2PTR(void *,SvIV(ST(3)))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Stepctx")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		ctx = INT2PTR(slurm_step_ctx_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Stepctx::daemon_per_node_hack",
			"ctx", "Slurm::Stepctx");
	}
;
#line 772 "Slurm.xs"
	        tmp32 = (uint32_t *)curr_task_num;

                RETVAL = slurm_step_ctx_daemon_per_node_hack(ctx, node_list, node_cnt, tmp32);
#line 1926 "Slurm.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Stepctx_launch); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Stepctx_launch)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "ctx, params, callbacks=NULL");
    {
#line 784 "Slurm.xs"
		slurm_step_launch_params_t lp;
		slurm_step_launch_callbacks_t *cb = NULL;
#line 1943 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_step_ctx_t *	ctx;
	HV *	params;
	HV *	callbacks;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Stepctx")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		ctx = INT2PTR(slurm_step_ctx_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Stepctx::launch",
			"ctx", "Slurm::Stepctx");
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    params = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::Stepctx::launch",
				"params");
		}
	} STMT_END
;

	if (items < 3)
	    callbacks = NULL;
	else {
	    STMT_START {
		    SV* const xsub_tmp_sv = ST(2);
		    SvGETMAGIC(xsub_tmp_sv);
		    if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
			callbacks = (HV*)SvRV(xsub_tmp_sv);
		    }
		    else{
			Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				    "Slurm::Stepctx::launch",
				    "callbacks");
		    }
	    } STMT_END
;
	}
#line 787 "Slurm.xs"
		if (hv_to_slurm_step_launch_params(params, &lp) < 0) {
			Perl_warn( aTHX_ "failed to convert slurm_step_launch_params_t");
			RETVAL = SLURM_ERROR;
		} else {
			if (callbacks) {
				set_slcb(callbacks);
				cb = &slcb;
			}
			RETVAL = slurm_step_launch(ctx, &lp, cb, -1);
			free_slurm_step_launch_params_memory(&lp);
		}
#line 2003 "Slurm.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Stepctx_launch_wait_start); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Stepctx_launch_wait_start)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	int	RETVAL;
	dXSTARG;
	slurm_step_ctx_t *	ctx;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Stepctx")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		ctx = INT2PTR(slurm_step_ctx_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Stepctx::launch_wait_start",
			"ctx", "Slurm::Stepctx");
	}
;

	RETVAL = slurm_step_launch_wait_start(ctx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Stepctx_launch_wait_finish); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Stepctx_launch_wait_finish)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	slurm_step_ctx_t *	ctx;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Stepctx")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		ctx = INT2PTR(slurm_step_ctx_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Stepctx::launch_wait_finish",
			"ctx", "Slurm::Stepctx");
	}
;

	slurm_step_launch_wait_finish(ctx);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Stepctx_launch_abort); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Stepctx_launch_abort)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ctx");
    {
	slurm_step_ctx_t *	ctx;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Stepctx")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		ctx = INT2PTR(slurm_step_ctx_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Stepctx::launch_abort",
			"ctx", "Slurm::Stepctx");
	}
;

	slurm_step_launch_abort(ctx);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Stepctx_launch_fwd_signal); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Stepctx_launch_fwd_signal)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "ctx, signo");
    {
	slurm_step_ctx_t *	ctx;
	uint16_t	signo = (unsigned short)SvUV(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Stepctx")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		ctx = INT2PTR(slurm_step_ctx_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Stepctx::launch_fwd_signal",
			"ctx", "Slurm::Stepctx");
	}
;

	slurm_step_launch_fwd_signal(ctx, signo);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_api_version); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_api_version)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
#line 829 "Slurm.xs"
		long version;
#line 2124 "Slurm.c"
	slurm_t	self;
	int	major;
	int	minor;
	int	micro;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_api_version() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 831 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		version = slurm_api_version();
		major = SLURM_VERSION_MAJOR(version);
		minor = SLURM_VERSION_MINOR(version);
		micro = SLURM_VERSION_MICRO(version);
#line 2149 "Slurm.c"
	XSprePUSH;	EXTEND(SP,3);
	PUSHs(sv_newmortal());
	sv_setiv(ST(0), (IV)major);
	PUSHs(sv_newmortal());
	sv_setiv(ST(1), (IV)minor);
	PUSHs(sv_newmortal());
	sv_setiv(ST(2), (IV)micro);
    }
    XSRETURN(3);
}


XS_EUPXS(XS_Slurm_load_ctl_conf); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_load_ctl_conf)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "self, update_time=0");
    {
#line 844 "Slurm.xs"
		slurm_ctl_conf_t *ctl_conf;
		int rc;
#line 2172 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	time_t	update_time;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_load_ctl_conf() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 2)
	    update_time = 0;
	else {
	    update_time = (time_t)SvNV(ST(1))
;
	}
#line 847 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_load_ctl_conf(update_time, &ctl_conf);
		if(rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = slurm_ctl_conf_to_hv(ctl_conf, RETVAL);
			slurm_free_ctl_conf(ctl_conf);
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 2211 "Slurm.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_print_ctl_conf); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_ctl_conf)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, out, conf");
    {
#line 870 "Slurm.xs"
		slurm_ctl_conf_t cc;
#line 2228 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	conf;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_ctl_conf() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    conf = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::print_ctl_conf",
				"conf");
		}
	} STMT_END
;
#line 872 "Slurm.xs"
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if (hv_to_slurm_ctl_conf(conf, &cc) < 0) {
			XSRETURN_UNDEF;
		}
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 2269 "Slurm.c"

	slurm_print_ctl_conf(out, &cc);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_ctl_conf_2_key_pairs); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_ctl_conf_2_key_pairs)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, conf");
    {
#line 893 "Slurm.xs"
		slurm_ctl_conf_t cc;
#line 2286 "Slurm.c"
	List	RETVAL;
	slurm_t	self;
	HV *	conf;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_ctl_conf_2_key_pairs() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    conf = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::ctl_conf_2_key_pairs",
				"conf");
		}
	} STMT_END
;
#line 895 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (hv_to_slurm_ctl_conf(conf, &cc) < 0) {
			XSRETURN_UNDEF;
		}
		RETVAL = (List)slurm_ctl_conf_2_key_pairs(&cc);
		if(RETVAL == NULL) {
			XSRETURN_UNDEF;
		}
#line 2327 "Slurm.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), "Slurm::List", (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_load_slurmd_status); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_load_slurmd_status)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
#line 917 "Slurm.xs"
		slurmd_status_t *status;
		int rc;
#line 2345 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_load_slurmd_status() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 920 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_load_slurmd_status(&status);
		if (rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = slurmd_status_to_hv(status, RETVAL);
			slurm_free_slurmd_status(status);
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 2376 "Slurm.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_print_slurmd_status); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_slurmd_status)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, out, slurmd_status");
    {
#line 943 "Slurm.xs"
		slurmd_status_t st;
#line 2393 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	slurmd_status;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_slurmd_status() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    slurmd_status = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::print_slurmd_status",
				"slurmd_status");
		}
	} STMT_END
;
#line 945 "Slurm.xs"
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if (hv_to_slurmd_status(slurmd_status, &st) < 0) {
			XSRETURN_UNDEF;
		}
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 2434 "Slurm.c"

	slurm_print_slurmd_status(out, &st);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_print_key_pairs); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_key_pairs)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "self, out, key_pairs, title");
    {
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	List	key_pairs;
	char *	title = (char *)SvPV_nolen(ST(3))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_key_pairs() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) && sv_derived_from(ST(2), "Slurm::List")) {
		IV tmp = SvIV((SV*)SvRV(ST(2)));
		key_pairs = INT2PTR(List,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::print_key_pairs",
			"key_pairs", "Slurm::List");
	}
;
#line 962 "Slurm.xs"
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 2484 "Slurm.c"

	slurm_print_key_pairs(out, key_pairs, title);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_update_step); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_update_step)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, step_msg");
    {
#line 976 "Slurm.xs"
		step_update_request_msg_t su_msg;
#line 2501 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	step_msg;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_update_step() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    step_msg = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::update_step",
				"step_msg");
		}
	} STMT_END
;
#line 978 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (hv_to_step_update_request_msg(step_msg, &su_msg) < 0) {
			RETVAL = SLURM_ERROR;
		} else {
			RETVAL = slurm_update_step(&su_msg);
		}
#line 2541 "Slurm.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_job_cpus_allocated_on_node_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_job_cpus_allocated_on_node_id)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, job_res, node_id");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	SV *	job_res = ST(1)
;
	int	node_id = (int)SvIV(ST(2))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_job_cpus_allocated_on_node_id() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 998 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(job_res) {
			RETVAL = slurm_job_cpus_allocated_on_node_id(
				(job_resources_t *)SV2ptr(job_res), node_id);
		} else {
			RETVAL = 0;
		}
#line 2584 "Slurm.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_job_cpus_allocated_on_node); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_job_cpus_allocated_on_node)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, job_res, node_name");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	SV *	job_res = ST(1)
;
	char *	node_name = (char *)SvPV_nolen(ST(2))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_job_cpus_allocated_on_node() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 1015 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(job_res) {
			RETVAL = slurm_job_cpus_allocated_on_node(
				(job_resources_t *)SV2ptr(job_res), node_name);
		} else {
			RETVAL = 0;
		}
#line 2627 "Slurm.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__job_info_msg_t_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__job_info_msg_t_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ji_msg");
    {
	job_info_msg_t *	ji_msg;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::job_info_msg_t")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		ji_msg = INT2PTR(job_info_msg_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::job_info_msg_t::DESTROY",
			"ji_msg", "Slurm::job_info_msg_t");
	}
;
#line 1038 "Slurm.xs"
		slurm_free_job_info_msg(ji_msg);
#line 2654 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_get_end_time); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_get_end_time)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, job_id");
    {
#line 1048 "Slurm.xs"
		time_t tmp_time;
		int rc;
#line 2670 "Slurm.c"
	time_t	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_get_end_time() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 1051 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_get_end_time(job_id, &tmp_time);
		if (rc == SLURM_SUCCESS) {
			RETVAL = tmp_time;
		} else {
			XSRETURN_UNDEF;
		}
#line 2698 "Slurm.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_get_rem_time); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_get_rem_time)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, job_id");
    {
	long	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_get_rem_time() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 1068 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 2733 "Slurm.c"

	RETVAL = slurm_get_rem_time(job_id);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_job_node_ready); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_job_node_ready)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, job_id");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_job_node_ready() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 1079 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 2770 "Slurm.c"

	RETVAL = slurm_job_node_ready(job_id);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_load_job); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_load_job)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "self, job_id, show_flags=0");
    {
#line 1093 "Slurm.xs"
		job_info_msg_t *ji_msg;
		int rc;
#line 2789 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint16_t	show_flags;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_load_job() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 3)
	    show_flags = 0;
	else {
	    show_flags = (unsigned short)SvUV(ST(2))
;
	}
#line 1096 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_load_job(&ji_msg, job_id, show_flags);
		if (rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = job_info_msg_to_hv(ji_msg, RETVAL);
			/* cannot free ji_msg because RETVAL holds data in it */
			if (rc >= 0) {
				hv_store_ptr(RETVAL, "job_info_msg", ji_msg, "Slurm::job_info_msg_t");
			}
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 2833 "Slurm.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_load_jobs); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_load_jobs)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "self, update_time=0, show_flags=0");
    {
#line 1125 "Slurm.xs"
		job_info_msg_t *ji_msg;
		int rc;
#line 2851 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	time_t	update_time;
	uint16_t	show_flags;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_load_jobs() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 2)
	    update_time = 0;
	else {
	    update_time = (time_t)SvNV(ST(1))
;
	}

	if (items < 3)
	    show_flags = 0;
	else {
	    show_flags = (unsigned short)SvUV(ST(2))
;
	}
#line 1128 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_load_jobs(update_time, &ji_msg, show_flags);
		if (rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = job_info_msg_to_hv(ji_msg, RETVAL);
			/* cannot free ji_msg because RETVAL holds data in it */
			if (rc >= 0) {
				hv_store_ptr(RETVAL, "job_info_msg", ji_msg, "Slurm::job_info_msg_t");
			}
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 2901 "Slurm.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_notify_job); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_notify_job)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, job_id, message");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	char *	message = (char *)SvPV_nolen(ST(2))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_notify_job() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 1154 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 2939 "Slurm.c"

	RETVAL = slurm_notify_job(job_id, message);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_pid2jobid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_pid2jobid)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, job_pid");
    {
#line 1168 "Slurm.xs"
		uint32_t tmp_pid;
		int rc;
#line 2958 "Slurm.c"
	uint32_t	RETVAL;
	dXSTARG;
	slurm_t	self;
	pid_t	job_pid = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_pid2jobid() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 1171 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_pid2jobid(job_pid, &tmp_pid);
		if (rc == SLURM_SUCCESS) {
			RETVAL = tmp_pid;
		} else {
			XSRETURN_UNDEF;
		}
#line 2986 "Slurm.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_print_job_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_job_info)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, out, job_info, one_liner=0");
    {
#line 1188 "Slurm.xs"
		job_info_t ji;
#line 3002 "Slurm.c"
	slurm_t	self;
	FILE*	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	job_info;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_job_info() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    job_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::print_job_info",
				"job_info");
		}
	} STMT_END
;

	if (items < 4)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(3))
;
	}
#line 1190 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if (hv_to_job_info(job_info, &ji) < 0) {
			XSRETURN_UNDEF;
		}
#line 3051 "Slurm.c"

	slurm_print_job_info(out, &ji, one_liner);
#line 1204 "Slurm.xs"
		xfree(ji.exc_node_inx);
		xfree(ji.node_inx);
		xfree(ji.req_node_inx);
#line 3058 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_print_job_info_msg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_job_info_msg)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, out, job_info_msg, one_liner=0");
    {
#line 1211 "Slurm.xs"
		job_info_msg_t ji_msg;
#line 3073 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	job_info_msg;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_job_info_msg() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    job_info_msg = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::print_job_info_msg",
				"job_info_msg");
		}
	} STMT_END
;

	if (items < 4)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(3))
;
	}
#line 1213 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if (hv_to_job_info_msg(job_info_msg, &ji_msg) < 0) {
			XSRETURN_UNDEF;
		}
#line 3122 "Slurm.c"

	slurm_print_job_info_msg(out, &ji_msg, one_liner);
#line 1227 "Slurm.xs"
		xfree(ji_msg.job_array);
#line 3127 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_sprint_job_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_sprint_job_info)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "self, job_info, one_liner=0");
    {
#line 1232 "Slurm.xs"
		job_info_t ji;
		char *tmp_str = NULL;
#line 3143 "Slurm.c"
	char_xfree *	RETVAL;
	slurm_t	self;
	HV *	job_info;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_sprint_job_info() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    job_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::sprint_job_info",
				"job_info");
		}
	} STMT_END
;

	if (items < 3)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(2))
;
	}
#line 1235 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_job_info(job_info, &ji) < 0) {
			XSRETURN_UNDEF;
		}
		tmp_str = slurm_sprint_job_info(&ji, one_liner);
		xfree(ji.exc_node_inx);
		xfree(ji.node_inx);
		xfree(ji.req_node_inx);
		RETVAL = tmp_str;
#line 3193 "Slurm.c"
	ST(0) = sv_newmortal();
	sv_setpv ((SV*)ST(0), RETVAL);
        xfree (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_update_job); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_update_job)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, job_info");
    {
#line 1254 "Slurm.xs"
		job_desc_msg_t update_msg;
#line 3211 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	job_info;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_update_job() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    job_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::update_job",
				"job_info");
		}
	} STMT_END
;
#line 1256 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_job_desc_msg(job_info, &update_msg) < 0) {
			XSRETURN_UNDEF;
		}
#line 3249 "Slurm.c"

	RETVAL = slurm_update_job(&update_msg);
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1267 "Slurm.xs"
		free_job_desc_msg_memory(&update_msg);
#line 3255 "Slurm.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_get_job_steps); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_get_job_steps)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 5)
       croak_xs_usage(cv,  "self, update_time=0, job_id=NO_VAL, step_id=NO_VAL, show_flags=0");
    {
#line 1278 "Slurm.xs"
		int rc;
		job_step_info_response_msg_t *resp_msg;
#line 3271 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	time_t	update_time;
	uint32_t	job_id;
	uint32_t	step_id;
	uint16_t	show_flags;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_get_job_steps() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 2)
	    update_time = 0;
	else {
	    update_time = (time_t)SvNV(ST(1))
;
	}

	if (items < 3)
	    job_id = NO_VAL;
	else {
	    job_id = (unsigned long)SvUV(ST(2))
;
	}

	if (items < 4)
	    step_id = NO_VAL;
	else {
	    step_id = (unsigned long)SvUV(ST(3))
;
	}

	if (items < 5)
	    show_flags = 0;
	else {
	    show_flags = (unsigned short)SvUV(ST(4))
;
	}
#line 1281 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_get_job_steps(update_time, job_id, step_id, &resp_msg, show_flags);
		if(rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = job_step_info_response_msg_to_hv(resp_msg, RETVAL);
			slurm_free_job_step_info_response_msg(resp_msg);
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 3334 "Slurm.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_print_job_step_info_msg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_job_step_info_msg)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, out, step_info_msg, one_liner=0");
    {
#line 1304 "Slurm.xs"
		job_step_info_response_msg_t si_msg;
#line 3351 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	step_info_msg;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_job_step_info_msg() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    step_info_msg = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::print_job_step_info_msg",
				"step_info_msg");
		}
	} STMT_END
;

	if (items < 4)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(3))
;
	}
#line 1306 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if(hv_to_job_step_info_response_msg(step_info_msg, &si_msg) < 0) {
			XSRETURN_UNDEF;
		}
#line 3400 "Slurm.c"

	slurm_print_job_step_info_msg(out, &si_msg, one_liner);
#line 1320 "Slurm.xs"
		xfree(si_msg.job_steps);
#line 3405 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_print_job_step_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_job_step_info)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, out, step_info, one_liner=0");
    {
#line 1325 "Slurm.xs"
		job_step_info_t si;
#line 3420 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	step_info;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_job_step_info() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    step_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::print_job_step_info",
				"step_info");
		}
	} STMT_END
;

	if (items < 4)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(3))
;
	}
#line 1327 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if(hv_to_job_step_info(step_info, &si) < 0) {
			XSRETURN_UNDEF;
		}
#line 3469 "Slurm.c"

	slurm_print_job_step_info(out, &si, one_liner);
#line 1341 "Slurm.xs"
		xfree(si.node_inx);
#line 3474 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_sprint_job_step_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_sprint_job_step_info)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "self, step_info, one_liner=0");
    {
#line 1346 "Slurm.xs"
		job_step_info_t si;
#line 3489 "Slurm.c"
	char_xfree *	RETVAL;
	slurm_t	self;
	HV *	step_info;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_sprint_job_step_info() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    step_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::sprint_job_step_info",
				"step_info");
		}
	} STMT_END
;

	if (items < 3)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(2))
;
	}
#line 1348 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_job_step_info(step_info, &si) < 0) {
			XSRETURN_UNDEF;
		}
		RETVAL = slurm_sprint_job_step_info(&si, one_liner);
		xfree(si.node_inx);
#line 3536 "Slurm.c"
	ST(0) = sv_newmortal();
	sv_setpv ((SV*)ST(0), RETVAL);
        xfree (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_job_step_layout_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_job_step_layout_get)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, job_id, step_id");
    {
#line 1364 "Slurm.xs"
		int rc;
		slurm_step_layout_t *layout;
#line 3555 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	step_id = (unsigned long)SvUV(ST(2))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_job_step_layout_get() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 1367 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		layout = slurm_job_step_layout_get(job_id, step_id);
		if(layout == NULL) {
			XSRETURN_UNDEF;
		} else {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = slurm_step_layout_to_hv(layout, RETVAL);
			slurm_job_step_layout_free(layout);
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		}
#line 3590 "Slurm.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_job_step_stat); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_job_step_stat)
{
    dVAR; dXSARGS;
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "self, job_id, step_id, nodelist=NULL, protocol_version");
    {
#line 1390 "Slurm.xs"
		int rc;
		job_step_stat_response_msg_t *resp_msg;
#line 3608 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	step_id = (unsigned long)SvUV(ST(2))
;
	char *	nodelist;
	uint16_t	protocol_version = (unsigned short)SvUV(ST(4))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_job_step_stat() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 4)
	    nodelist = NULL;
	else {
	    nodelist = (char *)SvPV_nolen(ST(3))
;
	}
#line 1393 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
                rc = slurm_job_step_stat(job_id, step_id, nodelist,
					 protocol_version, &resp_msg);
		if (rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = job_step_stat_response_msg_to_hv(resp_msg, RETVAL);
			slurm_job_step_stat_response_msg_free(resp_msg);
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			errno = rc;
			XSRETURN_UNDEF;
		}
#line 3655 "Slurm.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_job_step_get_pids); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_job_step_get_pids)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, job_id, step_id, nodelist=NULL");
    {
#line 1418 "Slurm.xs"
		int rc;
		job_step_pids_response_msg_t *resp_msg = NULL;
#line 3673 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	step_id = (unsigned long)SvUV(ST(2))
;
	char *	nodelist;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_job_step_get_pids() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 4)
	    nodelist = NULL;
	else {
	    nodelist = (char *)SvPV_nolen(ST(3))
;
	}
#line 1421 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_job_step_get_pids(job_id, step_id, nodelist, &resp_msg);
		if (rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = job_step_pids_response_msg_to_hv(resp_msg, RETVAL);
			slurm_job_step_pids_response_msg_free(resp_msg);
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			errno = rc;
			XSRETURN_UNDEF;
		}
#line 3717 "Slurm.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__node_info_msg_t_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__node_info_msg_t_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "ni_msg");
    {
	node_info_msg_t *	ni_msg;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::node_info_msg_t")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		ni_msg = INT2PTR(node_info_msg_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::node_info_msg_t::DESTROY",
			"ni_msg", "Slurm::node_info_msg_t");
	}
;
#line 1450 "Slurm.xs"
		slurm_free_node_info_msg(ni_msg);
#line 3745 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_load_node); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_load_node)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "self, update_time=0, show_flags=0");
    {
#line 1459 "Slurm.xs"
		node_info_msg_t *ni_msg = NULL;
		int rc;
#line 3761 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	time_t	update_time;
	uint16_t	show_flags;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_load_node() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 2)
	    update_time = 0;
	else {
	    update_time = (time_t)SvNV(ST(1))
;
	}

	if (items < 3)
	    show_flags = 0;
	else {
	    show_flags = (unsigned short)SvUV(ST(2))
;
	}
#line 1462 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_load_node(update_time, &ni_msg,
				     show_flags | SHOW_MIXED);
		if (rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			/* RETVAL holds ni_msg->select_nodeinfo, so delay free-ing the msg */
			rc = node_info_msg_to_hv(ni_msg, RETVAL);
			if (rc >= 0) {
				rc = hv_store_ptr(RETVAL, "node_info_msg", ni_msg, "Slurm::node_info_msg_t");
			}
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 3812 "Slurm.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_load_single_node); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_load_single_node)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "self, node_name, show_flags=0");
    {
#line 1489 "Slurm.xs"
		node_info_msg_t *ni_msg = NULL;
		int rc;
#line 3830 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	char *	node_name = (char *)SvPV_nolen(ST(1))
;
	uint16_t	show_flags;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_load_single_node() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 3)
	    show_flags = 0;
	else {
	    show_flags = (unsigned short)SvUV(ST(2))
;
	}
#line 1492 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_load_node_single(&ni_msg, node_name, show_flags | SHOW_MIXED);

		if (rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			/* RETVAL holds ni_msg->select_nodeinfo, so delay free-ing the msg */
			rc = node_info_msg_to_hv(ni_msg, RETVAL);
			if (rc >= 0) {
				rc = hv_store_ptr(RETVAL, "node_info_msg", ni_msg, "Slurm::node_info_msg_t");
			}
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 3875 "Slurm.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_print_node_info_msg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_node_info_msg)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, out, node_info_msg, one_liner=0");
    {
#line 1519 "Slurm.xs"
		node_info_msg_t ni_msg;
#line 3892 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	node_info_msg;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_node_info_msg() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    node_info_msg = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::print_node_info_msg",
				"node_info_msg");
		}
	} STMT_END
;

	if (items < 4)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(3))
;
	}
#line 1521 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if(hv_to_node_info_msg(node_info_msg, &ni_msg) < 0) {
			XSRETURN_UNDEF;
		}
#line 3941 "Slurm.c"

	slurm_print_node_info_msg(out, &ni_msg, one_liner);
#line 1535 "Slurm.xs"
		xfree(ni_msg.node_array);
#line 3946 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_print_node_table); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_node_table)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, out, node_info, one_liner=0");
    {
#line 1540 "Slurm.xs"
		node_info_t ni;
#line 3961 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	node_info;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_node_table() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    node_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::print_node_table",
				"node_info");
		}
	} STMT_END
;

	if (items < 4)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(3))
;
	}
#line 1542 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if(hv_to_node_info(node_info, &ni) < 0) {
			XSRETURN_UNDEF;
		}
#line 4010 "Slurm.c"

	slurm_print_node_table(out, &ni, one_liner);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_sprint_node_table); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_sprint_node_table)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "self, node_info, one_liner=0");
    {
#line 1559 "Slurm.xs"
		node_info_t ni;
#line 4027 "Slurm.c"
	char_xfree *	RETVAL;
	slurm_t	self;
	HV *	node_info;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_sprint_node_table() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    node_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::sprint_node_table",
				"node_info");
		}
	} STMT_END
;

	if (items < 3)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(2))
;
	}
#line 1561 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_node_info(node_info, &ni) < 0) {
			XSRETURN_UNDEF;
		}
		RETVAL = slurm_sprint_node_table(&ni, one_liner);
#line 4073 "Slurm.c"
	ST(0) = sv_newmortal();
	sv_setpv ((SV*)ST(0), RETVAL);
        xfree (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_update_node); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_update_node)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, update_req");
    {
#line 1576 "Slurm.xs"
		update_node_msg_t node_msg;
#line 4091 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	update_req;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_update_node() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    update_req = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::update_node",
				"update_req");
		}
	} STMT_END
;
#line 1578 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_update_node_msg(update_req, &node_msg) < 0) {
			XSRETURN_UNDEF;
		}
#line 4129 "Slurm.c"

	RETVAL = slurm_update_node(&node_msg);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_load_topo); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_load_topo)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
#line 1597 "Slurm.xs"
		topo_info_response_msg_t *topo_info_msg = NULL;
		int rc;
#line 4148 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_load_topo() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 1600 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_load_topo( &topo_info_msg);
		if(rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = topo_info_response_msg_to_hv(topo_info_msg, RETVAL);
			slurm_free_topo_info_msg(topo_info_msg);
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 4179 "Slurm.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_print_topo_info_msg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_topo_info_msg)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, out, topo_info_msg, one_liner=0");
    {
#line 1623 "Slurm.xs"
		topo_info_response_msg_t ti_msg;
#line 4196 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	topo_info_msg;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_topo_info_msg() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    topo_info_msg = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::print_topo_info_msg",
				"topo_info_msg");
		}
	} STMT_END
;

	if (items < 4)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(3))
;
	}
#line 1625 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if(hv_to_topo_info_response_msg(topo_info_msg, &ti_msg) < 0) {
			XSRETURN_UNDEF;
		}
#line 4245 "Slurm.c"

	slurm_print_topo_info_msg(out, &ti_msg, one_liner);
#line 1639 "Slurm.xs"
		xfree(ti_msg.topo_array);
#line 4250 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_print_topo_record); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_topo_record)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, out, topo_info, one_liner=0");
    {
#line 1644 "Slurm.xs"
		topo_info_t ti;
#line 4265 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	topo_info;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_topo_record() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    topo_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::print_topo_record",
				"topo_info");
		}
	} STMT_END
;

	if (items < 4)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(3))
;
	}
#line 1646 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if(hv_to_topo_info(topo_info, &ti) < 0) {
			XSRETURN_UNDEF;
		}
#line 4314 "Slurm.c"

	slurm_print_topo_record(out, &ti, one_liner);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_get_select_nodeinfo); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_get_select_nodeinfo)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "self, nodeinfo, data_type, state, data");
    {
#line 1670 "Slurm.xs"
		uint16_t tmp_16;
		char *tmp_str;
		bitstr_t *tmp_bitmap;
		select_nodeinfo_t *tmp_ptr;
#line 4334 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	dynamic_plugin_data_t *	nodeinfo;
	uint32_t	data_type = (unsigned long)SvUV(ST(2))
;
	uint32_t	state = (unsigned long)SvUV(ST(3))
;
	SV *	data = ST(4)
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_get_select_nodeinfo() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) && sv_derived_from(ST(1), "Slurm::dynamic_plugin_data_t")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		nodeinfo = INT2PTR(dynamic_plugin_data_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::get_select_nodeinfo",
			"nodeinfo", "Slurm::dynamic_plugin_data_t");
	}
;
#line 1675 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		switch(data_type) {
		case SELECT_NODEDATA_BITMAP_SIZE: /* data-> uint16_t */
		case SELECT_NODEDATA_SUBGRP_SIZE: /* data-> uint16_t */
		case SELECT_NODEDATA_SUBCNT:      /* data-> uint16_t */
			RETVAL = slurm_get_select_nodeinfo(nodeinfo, data_type, state, &tmp_16);
			if (RETVAL == 0) {
				sv_setuv(data, (UV)tmp_16);
			}
			break;
		case SELECT_NODEDATA_BITMAP:      /* data-> bitstr_t * needs to be
						   * freed with FREE_NULL_BITMAP */
			RETVAL = slurm_get_select_nodeinfo(nodeinfo, data_type, state, &tmp_bitmap);
			if (RETVAL == 0) {
				sv_setref_pv(data, "Slurm::Bitstr", tmp_bitmap);
			}
			break;
		case SELECT_NODEDATA_STR:         /* data-> char *  needs to be freed with xfree */
			RETVAL = slurm_get_select_nodeinfo(nodeinfo, data_type, state, &tmp_str);
			if (RETVAL == 0) {
				char *str;
				int len = strlen(tmp_str) + 1;
				New(0, str, len, char);
				Copy(tmp_str, str, len, char);
				xfree(tmp_str);
				sv_setpvn(data, str, len);
			}
			break;
		case SELECT_NODEDATA_PTR:         /* data-> select_nodeinfo_t *nodeinfo */
			RETVAL = slurm_get_select_nodeinfo(nodeinfo, data_type, state, &tmp_ptr);
			if (RETVAL == 0) {
				sv_setref_pv(data, "Slurm::select_nodeinfo_t", (void*)tmp_ptr);
			}
			break;
		default:
			RETVAL = slurm_get_select_nodeinfo(nodeinfo, data_type, state, NULL);
		}
#line 4407 "Slurm.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_load_partitions); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_load_partitions)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "self, update_time=0, show_flags=0");
    {
#line 1726 "Slurm.xs"
		partition_info_msg_t *part_info_msg;
		int rc;
#line 4424 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	time_t	update_time;
	uint16_t	show_flags;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_load_partitions() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 2)
	    update_time = 0;
	else {
	    update_time = (time_t)SvNV(ST(1))
;
	}

	if (items < 3)
	    show_flags = 0;
	else {
	    show_flags = (unsigned short)SvUV(ST(2))
;
	}
#line 1729 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_load_partitions(update_time, &part_info_msg,
					   show_flags);
		if (rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = partition_info_msg_to_hv(part_info_msg, RETVAL);
			slurm_free_partition_info_msg(part_info_msg);
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 4472 "Slurm.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_print_partition_info_msg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_partition_info_msg)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, out, part_info_msg, one_liner=0");
    {
#line 1753 "Slurm.xs"
		partition_info_msg_t pi_msg;
#line 4489 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	part_info_msg;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_partition_info_msg() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    part_info_msg = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::print_partition_info_msg",
				"part_info_msg");
		}
	} STMT_END
;

	if (items < 4)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(3))
;
	}
#line 1755 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if(hv_to_partition_info_msg(part_info_msg, &pi_msg) < 0) {
			XSRETURN_UNDEF;
		}
#line 4538 "Slurm.c"

	slurm_print_partition_info_msg(out, &pi_msg, one_liner);
#line 1769 "Slurm.xs"
		xfree(pi_msg.partition_array);
#line 4543 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_print_partition_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_partition_info)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, out, part_info, one_liner=0");
    {
#line 1774 "Slurm.xs"
		partition_info_t pi;
#line 4558 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	part_info;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_partition_info() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    part_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::print_partition_info",
				"part_info");
		}
	} STMT_END
;

	if (items < 4)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(3))
;
	}
#line 1776 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if(hv_to_partition_info(part_info, &pi) < 0) {
			XSRETURN_UNDEF;
		}
#line 4607 "Slurm.c"

	slurm_print_partition_info(out, &pi, one_liner);
#line 1790 "Slurm.xs"
		xfree(pi.node_inx);
#line 4612 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_sprint_partition_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_sprint_partition_info)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "self, part_info, one_liner=0");
    {
#line 1795 "Slurm.xs"
		partition_info_t pi;
#line 4627 "Slurm.c"
	char_xfree *	RETVAL;
	slurm_t	self;
	HV *	part_info;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_sprint_partition_info() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    part_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::sprint_partition_info",
				"part_info");
		}
	} STMT_END
;

	if (items < 3)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(2))
;
	}
#line 1797 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_partition_info(part_info, &pi) < 0) {
			XSRETURN_UNDEF;
		}
		RETVAL = slurm_sprint_partition_info(&pi, one_liner);
		xfree(pi.node_inx);
#line 4674 "Slurm.c"
	ST(0) = sv_newmortal();
	sv_setpv ((SV*)ST(0), RETVAL);
        xfree (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_create_partition); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_create_partition)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, part_info");
    {
#line 1813 "Slurm.xs"
		update_part_msg_t update_msg;
#line 4692 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	part_info;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_create_partition() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    part_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::create_partition",
				"part_info");
		}
	} STMT_END
;
#line 1815 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_update_part_msg(part_info, &update_msg) < 0) {
			XSRETURN_UNDEF;
		}
#line 4730 "Slurm.c"

	RETVAL = slurm_create_partition(&update_msg);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_update_partition); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_update_partition)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, part_info");
    {
#line 1829 "Slurm.xs"
		update_part_msg_t update_msg;
#line 4748 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	part_info;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_update_partition() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    part_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::update_partition",
				"part_info");
		}
	} STMT_END
;
#line 1831 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_update_part_msg(part_info, &update_msg) < 0) {
			XSRETURN_UNDEF;
		}
#line 4786 "Slurm.c"

	RETVAL = slurm_update_partition(&update_msg);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_delete_partition); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_delete_partition)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, delete_part_msg");
    {
#line 1845 "Slurm.xs"
		delete_part_msg_t dp_msg;
#line 4804 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	delete_part_msg;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_delete_partition() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    delete_part_msg = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::delete_partition",
				"delete_part_msg");
		}
	} STMT_END
;
#line 1847 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_delete_part_msg(delete_part_msg, &dp_msg) < 0) {
			XSRETURN_UNDEF;
		}
#line 4842 "Slurm.c"

	RETVAL = slurm_delete_partition(&dp_msg);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_load_reservations); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_load_reservations)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "self, update_time=0");
    {
#line 1866 "Slurm.xs"
		reserve_info_msg_t *resv_info_msg = NULL;
		int rc;
#line 4861 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;
	time_t	update_time;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_load_reservations() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 2)
	    update_time = 0;
	else {
	    update_time = (time_t)SvNV(ST(1))
;
	}
#line 1869 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_load_reservations(update_time, &resv_info_msg);
		if(rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = reserve_info_msg_to_hv(resv_info_msg, RETVAL);
			slurm_free_reservation_info_msg(resv_info_msg);
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 4900 "Slurm.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_create_reservation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_create_reservation)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, res_info");
    {
#line 1892 "Slurm.xs"
		resv_desc_msg_t resv_msg;
#line 4917 "Slurm.c"
	char_free *	RETVAL;
	slurm_t	self;
	HV *	res_info;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_create_reservation() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    res_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::create_reservation",
				"res_info");
		}
	} STMT_END
;
#line 1894 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_update_reservation_msg(res_info, &resv_msg) < 0) {
			XSRETURN_UNDEF;
		}
		RETVAL = slurm_create_reservation(&resv_msg);
		if (RETVAL == NULL) {
			XSRETURN_UNDEF;
		}
#line 4958 "Slurm.c"
	ST(0) = sv_newmortal();
	sv_setpv ((SV*)ST(0), RETVAL);
        free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_update_reservation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_update_reservation)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, res_info");
    {
#line 1912 "Slurm.xs"
		resv_desc_msg_t resv_msg;
#line 4976 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	res_info;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_update_reservation() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    res_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::update_reservation",
				"res_info");
		}
	} STMT_END
;
#line 1914 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_update_reservation_msg(res_info, &resv_msg) < 0) {
			XSRETURN_UNDEF;
		}
#line 5014 "Slurm.c"

	RETVAL = slurm_update_reservation(&resv_msg);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_delete_reservation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_delete_reservation)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, res_info");
    {
#line 1928 "Slurm.xs"
		reservation_name_msg_t resv_name;
#line 5032 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	res_info;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_delete_reservation() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    res_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::delete_reservation",
				"res_info");
		}
	} STMT_END
;
#line 1930 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_delete_reservation_msg(res_info, &resv_name) < 0) {
			XSRETURN_UNDEF;
		}
#line 5070 "Slurm.c"

	RETVAL = slurm_delete_reservation(&resv_name);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_print_reservation_info_msg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_reservation_info_msg)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, out, resv_info_msg, one_liner=0");
    {
#line 1944 "Slurm.xs"
		reserve_info_msg_t ri_msg;
		int i;
#line 5089 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	resv_info_msg;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_reservation_info_msg() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    resv_info_msg = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::print_reservation_info_msg",
				"resv_info_msg");
		}
	} STMT_END
;

	if (items < 4)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(3))
;
	}
#line 1947 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if(hv_to_reserve_info_msg(resv_info_msg, &ri_msg) < 0) {
			XSRETURN_UNDEF;
		}
#line 5138 "Slurm.c"

	slurm_print_reservation_info_msg(out, &ri_msg, one_liner);
#line 1961 "Slurm.xs"
		for (i = 0; i < ri_msg.record_count; i ++)
			xfree(ri_msg.reservation_array[i]);
		xfree(ri_msg.reservation_array);
#line 5145 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_print_reservation_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_print_reservation_info)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "self, out, resv_info, one_liner=0");
    {
#line 1968 "Slurm.xs"
		reserve_info_t ri;
#line 5160 "Slurm.c"
	slurm_t	self;
	FILE *	out = PerlIO_findFILE(IoIFP(sv_2io(ST(1))))
;
	HV *	resv_info;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_print_reservation_info() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    resv_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::print_reservation_info",
				"resv_info");
		}
	} STMT_END
;

	if (items < 4)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(3))
;
	}
#line 1970 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if (out == NULL) {
			Perl_croak (aTHX_ "Invalid output stream specified: FILE not found");
		}
		if(hv_to_reserve_info(resv_info, &ri) < 0) {
			XSRETURN_UNDEF;
		}
#line 5209 "Slurm.c"

	slurm_print_reservation_info(out, &ri, one_liner);
#line 1984 "Slurm.xs"
		xfree(ri.node_inx);
#line 5214 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm_sprint_reservation_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_sprint_reservation_info)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "self, resv_info, one_liner=0");
    {
#line 1989 "Slurm.xs"
		reserve_info_t ri;
#line 5229 "Slurm.c"
	char_xfree *	RETVAL;
	slurm_t	self;
	HV *	resv_info;
	int	one_liner;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_sprint_reservation_info() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    resv_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::sprint_reservation_info",
				"resv_info");
		}
	} STMT_END
;

	if (items < 3)
	    one_liner = 0;
	else {
	    one_liner = (int)SvIV(ST(2))
;
	}
#line 1991 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_reserve_info(resv_info, &ri) < 0) {
			XSRETURN_UNDEF;
		}
		RETVAL = slurm_sprint_reservation_info(&ri, one_liner);
		xfree(ri.node_inx);
#line 5276 "Slurm.c"
	ST(0) = sv_newmortal();
	sv_setpv ((SV*)ST(0), RETVAL);
        xfree (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_ping); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_ping)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "self, primary=1");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint16_t	primary;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_ping() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 2)
	    primary = 1;
	else {
	    primary = (unsigned short)SvUV(ST(1))
;
	}
#line 2012 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 5319 "Slurm.c"

	RETVAL = slurm_ping(primary);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_reconfigure); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_reconfigure)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_reconfigure() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 2023 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 5354 "Slurm.c"

	RETVAL = slurm_reconfigure();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_shutdown); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_shutdown)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "self, options=0");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint16_t	options;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_shutdown() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 2)
	    options = 0;
	else {
	    options = (unsigned short)SvUV(ST(1))
;
	}
#line 2033 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 5397 "Slurm.c"

	RETVAL = slurm_shutdown(options);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_takeover); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_takeover)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "self, backup_inx=1");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	int	backup_inx;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_takeover() -- self is not a blessed SV reference or correct package name" );
	}
;

	if (items < 2)
	    backup_inx = 1;
	else {
	    backup_inx = (int)SvIV(ST(1))
;
	}
#line 2044 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 5440 "Slurm.c"

	RETVAL = slurm_takeover(backup_inx);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_set_debug_level); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_set_debug_level)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, debug_level");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	debug_level = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_set_debug_level() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 2055 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 5477 "Slurm.c"

	RETVAL = slurm_set_debug_level(debug_level);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_set_schedlog_level); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_set_schedlog_level)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, schedlog_level");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	schedlog_level = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_set_schedlog_level() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 2066 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 5514 "Slurm.c"

	RETVAL = slurm_set_schedlog_level(schedlog_level);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_suspend); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_suspend)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, job_id");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_suspend() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 2082 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 5551 "Slurm.c"

	RETVAL = slurm_suspend(job_id);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_resume); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_resume)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, job_id");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_resume() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 2093 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 5588 "Slurm.c"

	RETVAL = slurm_resume(job_id);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_requeue); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_requeue)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, job_id, state");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	state = (unsigned long)SvUV(ST(2))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_requeue() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 2104 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 5627 "Slurm.c"

	RETVAL = slurm_requeue(job_id, state);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_checkpoint_able); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_checkpoint_able)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "self, job_id, step_id, start_time");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	step_id = (unsigned long)SvUV(ST(2))
;
	time_t	start_time;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_checkpoint_able() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 2120 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 5667 "Slurm.c"

	RETVAL = slurm_checkpoint_able(job_id, step_id, &start_time);
	sv_setnv(ST(3), (NV)start_time);
	SvSETMAGIC(ST(3));
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_checkpoint_disable); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_checkpoint_disable)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, job_id, step_id");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	step_id = (unsigned long)SvUV(ST(2))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_checkpoint_disable() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 2131 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 5708 "Slurm.c"

	RETVAL = slurm_checkpoint_disable(job_id, step_id);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_checkpoint_enable); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_checkpoint_enable)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "self, job_id, step_id");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	step_id = (unsigned long)SvUV(ST(2))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_checkpoint_enable() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 2142 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 5747 "Slurm.c"

	RETVAL = slurm_checkpoint_enable(job_id, step_id);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_checkpoint_create); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_checkpoint_create)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "self, job_id, step_id, max_wait, image_dir");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	step_id = (unsigned long)SvUV(ST(2))
;
	uint16_t	max_wait = (unsigned short)SvUV(ST(3))
;
	char *	image_dir = (char *)SvPV_nolen(ST(4))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_checkpoint_create() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 2153 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 5790 "Slurm.c"

	RETVAL = slurm_checkpoint_create(job_id, step_id, max_wait, image_dir);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_checkpoint_requeue); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_checkpoint_requeue)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "self, job_id, max_wait, image_dir");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint16_t	max_wait = (unsigned short)SvUV(ST(2))
;
	char *	image_dir = (char *)SvPV_nolen(ST(3))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_checkpoint_requeue() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 2164 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 5831 "Slurm.c"

	RETVAL = slurm_checkpoint_requeue(job_id, max_wait, image_dir);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_checkpoint_vacate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_checkpoint_vacate)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "self, job_id, step_id, max_wait, image_dir");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	step_id = (unsigned long)SvUV(ST(2))
;
	uint16_t	max_wait = (unsigned short)SvUV(ST(3))
;
	char *	image_dir = (char *)SvPV_nolen(ST(4))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_checkpoint_vacate() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 2175 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 5874 "Slurm.c"

	RETVAL = slurm_checkpoint_vacate(job_id, step_id, max_wait, image_dir);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_checkpoint_restart); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_checkpoint_restart)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "self, job_id, step_id, stick, image_dir");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	step_id = (unsigned long)SvUV(ST(2))
;
	uint16_t	stick = (unsigned short)SvUV(ST(3))
;
	char *	image_dir = (char *)SvPV_nolen(ST(4))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_checkpoint_restart() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 2186 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 5917 "Slurm.c"

	RETVAL = slurm_checkpoint_restart(job_id, step_id, stick, image_dir);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_checkpoint_complete); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_checkpoint_complete)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "self, job_id, step_id, begin_time, error_code, error_msg");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	step_id = (unsigned long)SvUV(ST(2))
;
	time_t	begin_time = (time_t)SvNV(ST(3))
;
	uint32_t	error_code = (unsigned long)SvUV(ST(4))
;
	char *	error_msg = (char *)SvPV_nolen(ST(5))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_checkpoint_complete() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 2197 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 5962 "Slurm.c"

	RETVAL = slurm_checkpoint_complete(job_id, step_id, begin_time, error_code, error_msg);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_checkpoint_error); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_checkpoint_error)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "self, job_id, step_id, error_code, error_msg");
    {
#line 2208 "Slurm.xs"
		char* err_msg = NULL;
#line 5980 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint32_t	step_id = (unsigned long)SvUV(ST(2))
;
	uint32_t	error_code;
	char *	error_msg;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_checkpoint_error() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 2210 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		error_code = SLURM_SUCCESS;
		RETVAL = slurm_checkpoint_error(job_id, step_id, (uint32_t *)&error_code, &err_msg);
		Newz(0, error_msg, strlen(err_msg), char);
		Copy(err_msg, error_msg, strlen(err_msg), char);
		xfree(err_msg);
#line 6011 "Slurm.c"
	sv_setpv((SV*)ST(4), error_msg);
	SvSETMAGIC(ST(4));
	sv_setuv(ST(3), (UV)error_code);
	SvSETMAGIC(ST(3));
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_checkpoint_tasks); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_checkpoint_tasks)
{
    dVAR; dXSARGS;
    if (items != 7)
       croak_xs_usage(cv,  "self, job_id, step_id, begin_time, image_dir, max_wait, nodelist");
    {
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	uint32_t	job_id = (unsigned long)SvUV(ST(1))
;
	uint16_t	step_id = (unsigned short)SvUV(ST(2))
;
	time_t	begin_time = (time_t)SvNV(ST(3))
;
	char *	image_dir = (char *)SvPV_nolen(ST(4))
;
	uint16_t	max_wait = (unsigned short)SvUV(ST(5))
;
	char *	nodelist = (char *)SvPV_nolen(ST(6))
;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_checkpoint_tasks() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 2226 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
#line 6060 "Slurm.c"

	RETVAL = slurm_checkpoint_tasks(job_id, step_id, begin_time, image_dir, max_wait, nodelist);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_set_trigger); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_set_trigger)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, trigger_info");
    {
#line 2241 "Slurm.xs"
		trigger_info_t ti;
#line 6078 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	trigger_info;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_set_trigger() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    trigger_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::set_trigger",
				"trigger_info");
		}
	} STMT_END
;
#line 2243 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
	       if(hv_to_trigger_info(trigger_info, &ti) < 0) {
			XSRETURN_UNDEF;
		}
#line 6116 "Slurm.c"

	RETVAL = slurm_set_trigger(&ti);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_clear_trigger); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_clear_trigger)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, trigger_info");
    {
#line 2256 "Slurm.xs"
		trigger_info_t ti;
#line 6134 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	trigger_info;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_clear_trigger() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    trigger_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::clear_trigger",
				"trigger_info");
		}
	} STMT_END
;
#line 2258 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_trigger_info(trigger_info, &ti) < 0) {
			XSRETURN_UNDEF;
		}
#line 6172 "Slurm.c"

	RETVAL = slurm_clear_trigger(&ti);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_get_triggers); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_get_triggers)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
#line 2272 "Slurm.xs"
		trigger_info_msg_t *ti_msg;
		int rc;
#line 6191 "Slurm.c"
	HV *	RETVAL;
	slurm_t	self;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_get_triggers() -- self is not a blessed SV reference or correct package name" );
	}
;
#line 2275 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		rc = slurm_get_triggers(&ti_msg);
		if(rc == SLURM_SUCCESS) {
			RETVAL = newHV();
			sv_2mortal((SV*)RETVAL);
			rc = trigger_info_msg_to_hv(ti_msg, RETVAL);
			slurm_free_trigger_msg(ti_msg);
			if (rc < 0) {
				XSRETURN_UNDEF;
			}
		} else {
			XSRETURN_UNDEF;
		}
#line 6222 "Slurm.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm_pull_trigger); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm_pull_trigger)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "self, trigger_info");
    {
#line 2298 "Slurm.xs"
		trigger_info_t ti;
#line 6239 "Slurm.c"
	int	RETVAL;
	dXSTARG;
	slurm_t	self;
	HV *	trigger_info;

        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm") ) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(slurm_t,tmp);
	} else if(SvPOK(ST(0)) && !strcmp("Slurm", SvPV_nolen(ST(0))))
	        self = &default_slurm_object;
	else {
	        Perl_croak(aTHX_ "Slurm::slurm_pull_trigger() -- self is not a blessed SV reference or correct package name" );
	}
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(1);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    trigger_info = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not a HASH reference",
				"Slurm::pull_trigger",
				"trigger_info");
		}
	} STMT_END
;
#line 2300 "Slurm.xs"
		if (self); /* this is needed to avoid a warning about
			      unused variables.  But if we take slurm_t self
			      out of the mix Slurm-> doesn't work,
			      only Slurm::
			    */
		if(hv_to_trigger_info(trigger_info, &ti) < 0) {
			XSRETURN_UNDEF;
		}
#line 6277 "Slurm.c"

	RETVAL = slurm_pull_trigger(&ti);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Hostlist_create); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Hostlist_create)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hostlist");
    {
	hostlist_t	RETVAL;
	char*	hostlist = (char *)SvPV_nolen(ST(0))
;

	RETVAL = slurm_hostlist_create(hostlist);
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), "Slurm::Hostlist", (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Hostlist_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Hostlist_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hl");
    {
	int	RETVAL;
	dXSTARG;
	hostlist_t	hl;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Hostlist")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		hl = INT2PTR(hostlist_t,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Hostlist::count",
			"hl", "Slurm::Hostlist");
	}
;

	RETVAL = slurm_hostlist_count(hl);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Hostlist_find); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Hostlist_find)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "hl, hostname");
    {
	int	RETVAL;
	dXSTARG;
	hostlist_t	hl;
	char*	hostname = (char *)SvPV_nolen(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Hostlist")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		hl = INT2PTR(hostlist_t,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Hostlist::find",
			"hl", "Slurm::Hostlist");
	}
;

	RETVAL = slurm_hostlist_find(hl, hostname);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Hostlist_push); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Hostlist_push)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "hl, hosts");
    {
	int	RETVAL;
	dXSTARG;
	hostlist_t	hl;
	char*	hosts = (char *)SvPV_nolen(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Hostlist")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		hl = INT2PTR(hostlist_t,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Hostlist::push",
			"hl", "Slurm::Hostlist");
	}
;

	RETVAL = slurm_hostlist_push(hl, hosts);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Hostlist_push_host); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Hostlist_push_host)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "hl, host");
    {
	int	RETVAL;
	dXSTARG;
	hostlist_t	hl;
	char*	host = (char *)SvPV_nolen(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Hostlist")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		hl = INT2PTR(hostlist_t,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Hostlist::push_host",
			"hl", "Slurm::Hostlist");
	}
;

	RETVAL = slurm_hostlist_push_host(hl, host);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Hostlist_ranged_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Hostlist_ranged_string)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hl");
    {
	char_xfree *	RETVAL;
	hostlist_t	hl;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Hostlist")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		hl = INT2PTR(hostlist_t,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Hostlist::ranged_string",
			"hl", "Slurm::Hostlist");
	}
;
#line 2334 "Slurm.xs"
		RETVAL = slurm_hostlist_ranged_string_xmalloc(hl);
		if (RETVAL == NULL) {
			XSRETURN_UNDEF;
		}
#line 6447 "Slurm.c"
	ST(0) = sv_newmortal();
	sv_setpv ((SV*)ST(0), RETVAL);
        xfree (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Hostlist_shift); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Hostlist_shift)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "hl= NULL");
    {
	char_free *	RETVAL;
	hostlist_t	hl;

	if (items < 1)
	    hl = NULL;
	else {
	    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Hostlist")) {
		    IV tmp = SvIV((SV*)SvRV(ST(0)));
		    hl = INT2PTR(hostlist_t,tmp);
	    } else {
		    Perl_croak(aTHX_ "%s: %s is not of type %s",
			    "Slurm::Hostlist::shift",
			    "hl", "Slurm::Hostlist");
	    }
;
	}
#line 2344 "Slurm.xs"
		RETVAL = slurm_hostlist_shift(hl);
		if (RETVAL == NULL) {
			XSRETURN_UNDEF;
		}
#line 6484 "Slurm.c"
	ST(0) = sv_newmortal();
	sv_setpv ((SV*)ST(0), RETVAL);
        free (RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Hostlist_uniq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Hostlist_uniq)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hl");
    {
	hostlist_t	hl;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Hostlist")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		hl = INT2PTR(hostlist_t,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Hostlist::uniq",
			"hl", "Slurm::Hostlist");
	}
;

	slurm_hostlist_uniq(hl);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Hostlist_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Hostlist_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hl");
    {
	hostlist_t	hl;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Hostlist")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		hl = INT2PTR(hostlist_t,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Hostlist::DESTROY",
			"hl", "Slurm::Hostlist");
	}
;
#line 2357 "Slurm.xs"
		slurm_hostlist_destroy(hl);
#line 6538 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__List_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__List_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "l");
    {
	int	RETVAL;
	dXSTARG;
	List	l;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::List")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		l = INT2PTR(List,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::List::count",
			"l", "Slurm::List");
	}
;

	RETVAL = slurm_list_count(l);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__List_is_empty); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__List_is_empty)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "l");
    {
	int	RETVAL;
	dXSTARG;
	List	l;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::List")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		l = INT2PTR(List,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::List::is_empty",
			"l", "Slurm::List");
	}
;

	RETVAL = slurm_list_is_empty(l);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__List_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__List_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "l");
    {
	List	l;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::List")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		l = INT2PTR(List,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::List::DESTROY",
			"l", "Slurm::List");
	}
;
#line 2385 "Slurm.xs"
		slurm_list_destroy(l);
#line 6620 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__ListIterator_create); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__ListIterator_create)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "l");
    {
	ListIterator	RETVAL;
	List	l;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::List")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		l = INT2PTR(List,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::ListIterator::create",
			"l", "Slurm::List");
	}
;

	RETVAL = slurm_list_iterator_create(l);
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), "Slurm::ListIterator", (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__ListIterator_reset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__ListIterator_reset)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	ListIterator	i;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::ListIterator")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		i = INT2PTR(ListIterator,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::ListIterator::reset",
			"i", "Slurm::ListIterator");
	}
;

	slurm_list_iterator_reset(i);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__ListIterator_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__ListIterator_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	ListIterator	i;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::ListIterator")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		i = INT2PTR(ListIterator,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::ListIterator::DESTROY",
			"i", "Slurm::ListIterator");
	}
;
#line 2413 "Slurm.xs"
		slurm_list_iterator_destroy(i);
#line 6699 "Slurm.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Bitstr_alloc); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_alloc)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "nbits");
    {
	bitstr_t *	RETVAL;
	bitoff_t	nbits = (bitoff_t)SvIV(ST(0))
;

	RETVAL = slurm_bit_alloc(nbits);
#line 2425 "Slurm.xs"
		if(RETVAL == NULL) {
			XSRETURN_UNDEF;
		}
#line 6721 "Slurm.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), "Slurm::Bitstr", (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_copy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_copy)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	bitstr_t *	RETVAL;
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::copy",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_copy(b);
#line 2432 "Slurm.xs"
		if(RETVAL == NULL) {
			XSRETURN_UNDEF;
		}
#line 6754 "Slurm.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), "Slurm::Bitstr", (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_test); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_test)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, bit");
    {
	int	RETVAL;
	dXSTARG;
	bitstr_t *	b;
	bitoff_t	bit = (bitoff_t)SvIV(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::test",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_test(b, bit);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_set)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, bit");
    {
	bitstr_t *	b;
	bitoff_t	bit = (bitoff_t)SvIV(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::set",
			"b", "Slurm::Bitstr");
	}
;

	slurm_bit_set(b, bit);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Bitstr_clear); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_clear)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, bit");
    {
	bitstr_t *	b;
	bitoff_t	bit = (bitoff_t)SvIV(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::clear",
			"b", "Slurm::Bitstr");
	}
;

	slurm_bit_clear(b, bit);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Bitstr_nset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_nset)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "b, start, stop");
    {
	bitstr_t *	b;
	bitoff_t	start = (bitoff_t)SvIV(ST(1))
;
	bitoff_t	stop = (bitoff_t)SvIV(ST(2))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::nset",
			"b", "Slurm::Bitstr");
	}
;

	slurm_bit_nset(b, start, stop);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Bitstr_nclear); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_nclear)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "b, start, stop");
    {
	bitstr_t *	b;
	bitoff_t	start = (bitoff_t)SvIV(ST(1))
;
	bitoff_t	stop = (bitoff_t)SvIV(ST(2))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::nclear",
			"b", "Slurm::Bitstr");
	}
;

	slurm_bit_nclear(b, start, stop);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Bitstr_ffc); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_ffc)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	bitoff_t	RETVAL;
	dXSTARG;
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::ffc",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_ffc(b);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_ffs); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_ffs)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	bitoff_t	RETVAL;
	dXSTARG;
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::ffs",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_ffs(b);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_fls); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_fls)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	bitoff_t	RETVAL;
	dXSTARG;
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::fls",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_fls(b);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_nffc); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_nffc)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, n");
    {
	bitoff_t	RETVAL;
	dXSTARG;
	bitstr_t *	b;
	int	n = (int)SvIV(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::nffc",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_nffc(b, n);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_nffs); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_nffs)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, n");
    {
	bitoff_t	RETVAL;
	dXSTARG;
	bitstr_t *	b;
	int	n = (int)SvIV(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::nffs",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_nffs(b, n);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_noc); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_noc)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "b, n, seed");
    {
	bitoff_t	RETVAL;
	dXSTARG;
	bitstr_t *	b;
	int	n = (int)SvIV(ST(1))
;
	int	seed = (int)SvIV(ST(2))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::noc",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_noc(b, n, seed);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	bitoff_t	RETVAL;
	dXSTARG;
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::size",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_size(b);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_and); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_and)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b1, b2");
    {
	bitstr_t *	b1;
	bitstr_t *	b2;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b1 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::and",
			"b1", "Slurm::Bitstr");
	}
;

	if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) && sv_derived_from(ST(1), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		b2 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::and",
			"b2", "Slurm::Bitstr");
	}
;

	slurm_bit_and(b1, b2);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Bitstr_not); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_not)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::not",
			"b", "Slurm::Bitstr");
	}
;

	slurm_bit_not(b);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Bitstr_or); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_or)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b1, b2");
    {
	bitstr_t *	b1;
	bitstr_t *	b2;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b1 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::or",
			"b1", "Slurm::Bitstr");
	}
;

	if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) && sv_derived_from(ST(1), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		b2 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::or",
			"b2", "Slurm::Bitstr");
	}
;

	slurm_bit_or(b1, b2);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Bitstr_copybits); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_copybits)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b1, b2");
    {
	bitstr_t *	b1;
	bitstr_t *	b2;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b1 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::copybits",
			"b1", "Slurm::Bitstr");
	}
;

	if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) && sv_derived_from(ST(1), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		b2 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::copybits",
			"b2", "Slurm::Bitstr");
	}
;

	slurm_bit_copybits(b1, b2);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Bitstr_set_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_set_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	int	RETVAL;
	dXSTARG;
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::set_count",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_set_count(b);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_set_count_range); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_set_count_range)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "b, start, end");
    {
	int	RETVAL;
	dXSTARG;
	bitstr_t *	b;
	int	start = (int)SvIV(ST(1))
;
	int	end = (int)SvIV(ST(2))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::set_count_range",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_set_count_range(b, start, end);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_clear_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_clear_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	int	RETVAL;
	dXSTARG;
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::clear_count",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_clear_count(b);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_nset_max_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_nset_max_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	int	RETVAL;
	dXSTARG;
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::nset_max_count",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_nset_max_count(b);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_rotate_copy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_rotate_copy)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "b, n, nbits");
    {
	bitstr_t *	RETVAL;
	bitstr_t *	b;
	int	n = (int)SvIV(ST(1))
;
	bitoff_t	nbits = (bitoff_t)SvIV(ST(2))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::rotate_copy",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_rotate_copy(b, n, nbits);
#line 2499 "Slurm.xs"
		if(RETVAL == NULL) {
			XSRETURN_UNDEF;
		}
#line 7386 "Slurm.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), "Slurm::Bitstr", (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_rotate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_rotate)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, n");
    {
	bitstr_t *	b;
	int	n = (int)SvIV(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::rotate",
			"b", "Slurm::Bitstr");
	}
;

	slurm_bit_rotate(b, n);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Bitstr_fmt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_fmt)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
#line 2511 "Slurm.xs"
		int len = 1, bits;
		char *tmp_str;
#line 7431 "Slurm.c"
	char *	RETVAL;
	dXSTARG;
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::fmt",
			"b", "Slurm::Bitstr");
	}
;
#line 2514 "Slurm.xs"
		bits = slurm_bit_size(b);
		while(bits > 0) {
			bits /= 10;
			len ++;
		}
		bits = slurm_bit_size(b);
		len *= bits;
		New(0, tmp_str, len, char);
		slurm_bit_fmt(tmp_str, len, b);
		len = strlen(tmp_str) + 1;
		New(0, RETVAL, len, char);
		Copy(tmp_str, RETVAL, len, char);
		Safefree(tmp_str);
#line 7459 "Slurm.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_unfmt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_unfmt)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, str");
    {
	int	RETVAL;
	dXSTARG;
	bitstr_t *	b;
	char *	str = (char *)SvPV_nolen(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::unfmt",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_unfmt(b, str);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_fmt2int); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_fmt2int)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "str");
    {
#line 2538 "Slurm.xs"
		int i = 0, *array;
#line 7505 "Slurm.c"
	AV *	RETVAL;
	char *	str = (char *)SvPV_nolen(ST(0))
;
#line 2540 "Slurm.xs"
		array = slurm_bitfmt2int(str);
		RETVAL = newAV();
		while (array[i] != -1) {
			av_store_int(RETVAL, i, array[i]);
			i ++;
		}
		xfree(array);
#line 7517 "Slurm.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_fmt_hexmask); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_fmt_hexmask)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
#line 2554 "Slurm.xs"
		char *tmp_str;
		int len;
#line 7535 "Slurm.c"
	char *	RETVAL;
	dXSTARG;
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::fmt_hexmask",
			"b", "Slurm::Bitstr");
	}
;
#line 2557 "Slurm.xs"
		tmp_str = slurm_bit_fmt_hexmask(b);
		len = strlen(tmp_str) + 1;
		New(0, RETVAL, len, char);
		Copy(tmp_str, RETVAL, len, char);
		xfree(tmp_str);
#line 7555 "Slurm.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_unfmt_hexmask); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_unfmt_hexmask)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, str");
    {
	int	RETVAL;
	dXSTARG;
	bitstr_t *	b;
	char *	str = (char *)SvPV_nolen(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::unfmt_hexmask",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_unfmt_hexmask(b, str);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_fmt_binmask); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_fmt_binmask)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
#line 2574 "Slurm.xs"
		char *tmp_str;
		int len;
#line 7602 "Slurm.c"
	char *	RETVAL;
	dXSTARG;
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::fmt_binmask",
			"b", "Slurm::Bitstr");
	}
;
#line 2577 "Slurm.xs"
		tmp_str = slurm_bit_fmt_binmask(b);
		len = strlen(tmp_str) + 1;
		New(0, RETVAL, len, char);
		Copy(tmp_str, RETVAL, len, char);
		xfree(tmp_str);
#line 7622 "Slurm.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_unfmt_binmask); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_unfmt_binmask)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, str");
    {
	int	RETVAL;
	dXSTARG;
	bitstr_t *	b;
	char *	str = (char *)SvPV_nolen(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::unfmt_binmask",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_unfmt_binmask(b, str);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_fill_gaps); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_fill_gaps)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::fill_gaps",
			"b", "Slurm::Bitstr");
	}
;

	slurm_bit_fill_gaps(b);
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slurm__Bitstr_super_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_super_set)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b1, b2");
    {
	int	RETVAL;
	dXSTARG;
	bitstr_t *	b1;
	bitstr_t *	b2;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b1 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::super_set",
			"b1", "Slurm::Bitstr");
	}
;

	if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) && sv_derived_from(ST(1), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		b2 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::super_set",
			"b2", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_super_set(b1, b2);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_overlap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_overlap)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b1, b2");
    {
	int	RETVAL;
	dXSTARG;
	bitstr_t *	b1;
	bitstr_t *	b2;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b1 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::overlap",
			"b1", "Slurm::Bitstr");
	}
;

	if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) && sv_derived_from(ST(1), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		b2 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::overlap",
			"b2", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_overlap(b1, b2);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_equal); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_equal)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b1, b2");
    {
	int	RETVAL;
	dXSTARG;
	bitstr_t *	b1;
	bitstr_t *	b2;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b1 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::equal",
			"b1", "Slurm::Bitstr");
	}
;

	if (sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) && sv_derived_from(ST(1), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		b2 = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::equal",
			"b2", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_equal(b1, b2);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_pick_cnt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_pick_cnt)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, nbits");
    {
	bitstr_t *	RETVAL;
	bitstr_t *	b;
	bitoff_t	nbits = (bitoff_t)SvIV(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::pick_cnt",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_pick_cnt(b, nbits);
#line 2604 "Slurm.xs"
		if(RETVAL == NULL) {
			XSRETURN_UNDEF;
		}
#line 7828 "Slurm.c"
	ST(0) = sv_newmortal();
	sv_setref_pv( ST(0), "Slurm::Bitstr", (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_get_bit_num); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_get_bit_num)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, pos");
    {
	bitoff_t	RETVAL;
	dXSTARG;
	bitstr_t *	b;
	int	pos = (int)SvIV(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::get_bit_num",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_get_bit_num(b, pos);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_get_pos_num); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_get_pos_num)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, pos");
    {
	int	RETVAL;
	dXSTARG;
	bitstr_t *	b;
	bitoff_t	pos = (bitoff_t)SvIV(ST(1))
;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::get_pos_num",
			"b", "Slurm::Bitstr");
	}
;

	RETVAL = slurm_bit_get_pos_num(b, pos);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slurm__Bitstr_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slurm__Bitstr_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	bitstr_t *	b;

	if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) && sv_derived_from(ST(0), "Slurm::Bitstr")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		b = INT2PTR(bitstr_t *,tmp);
	} else {
		Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Slurm::Bitstr::DESTROY",
			"b", "Slurm::Bitstr");
	}
;
#line 2617 "Slurm.xs"
		FREE_NULL_BITMAP(b);
#line 7916 "Slurm.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Slurm); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Slurm)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        (void)newXSproto_portable("Slurm::new", XS_Slurm_new, file, ";$");
        (void)newXSproto_portable("Slurm::DESTROY", XS_Slurm_DESTROY, file, "$");
        (void)newXSproto_portable("Slurm::get_errno", XS_Slurm_get_errno, file, "$");
        (void)newXSproto_portable("Slurm::strerror", XS_Slurm_strerror, file, "$;$");
        (void)newXSproto_portable("Slurm::preempt_mode_string", XS_Slurm_preempt_mode_string, file, "$$");
        (void)newXSproto_portable("Slurm::preempt_mode_num", XS_Slurm_preempt_mode_num, file, "$$");
        (void)newXSproto_portable("Slurm::job_reason_string", XS_Slurm_job_reason_string, file, "$$");
        (void)newXSproto_portable("Slurm::job_state_string", XS_Slurm_job_state_string, file, "$$");
        (void)newXSproto_portable("Slurm::job_state_string_compact", XS_Slurm_job_state_string_compact, file, "$$");
        (void)newXSproto_portable("Slurm::job_state_num", XS_Slurm_job_state_num, file, "$$");
        (void)newXSproto_portable("Slurm::reservation_flags_string", XS_Slurm_reservation_flags_string, file, "$$");
        (void)newXSproto_portable("Slurm::node_state_string", XS_Slurm_node_state_string, file, "$$");
        (void)newXSproto_portable("Slurm::node_state_string_compact", XS_Slurm_node_state_string_compact, file, "$$");
        (void)newXSproto_portable("Slurm::private_data_string", XS_Slurm_private_data_string, file, "$$");
        (void)newXSproto_portable("Slurm::accounting_enforce_string", XS_Slurm_accounting_enforce_string, file, "$$");
        (void)newXSproto_portable("Slurm::node_use_string", XS_Slurm_node_use_string, file, "$$");
        (void)newXSproto_portable("Slurm::allocate_resources", XS_Slurm_allocate_resources, file, "$$");
        (void)newXSproto_portable("Slurm::allocate_resources_blocking", XS_Slurm_allocate_resources_blocking, file, "$$;$$");
        (void)newXSproto_portable("Slurm::allocation_lookup", XS_Slurm_allocation_lookup, file, "$$");
        (void)newXSproto_portable("Slurm::read_hostfile", XS_Slurm_read_hostfile, file, "$$$");
        (void)newXSproto_portable("Slurm::allocation_msg_thr_create", XS_Slurm_allocation_msg_thr_create, file, "$$$");
        (void)newXSproto_portable("Slurm::allocation_msg_thr_destroy", XS_Slurm_allocation_msg_thr_destroy, file, "$$");
        (void)newXSproto_portable("Slurm::submit_batch_job", XS_Slurm_submit_batch_job, file, "$$");
        (void)newXSproto_portable("Slurm::job_will_run", XS_Slurm_job_will_run, file, "$$");
        (void)newXSproto_portable("Slurm::sbcast_lookup", XS_Slurm_sbcast_lookup, file, "$$$");
        (void)newXSproto_portable("Slurm::kill_job", XS_Slurm_kill_job, file, "$$$;$");
        (void)newXSproto_portable("Slurm::kill_job_step", XS_Slurm_kill_job_step, file, "$$$$");
        (void)newXSproto_portable("Slurm::signal_job", XS_Slurm_signal_job, file, "$$$");
        (void)newXSproto_portable("Slurm::signal_job_step", XS_Slurm_signal_job_step, file, "$$$$");
        (void)newXSproto_portable("Slurm::complete_job", XS_Slurm_complete_job, file, "$$;$");
        (void)newXSproto_portable("Slurm::terminate_job_step", XS_Slurm_terminate_job_step, file, "$$$");
        (void)newXSproto_portable("Slurm::step_ctx_create", XS_Slurm_step_ctx_create, file, "$$");
        (void)newXSproto_portable("Slurm::step_ctx_create_no_alloc", XS_Slurm_step_ctx_create_no_alloc, file, "$$$");
        (void)newXSproto_portable("Slurm::Stepctx::get", XS_Slurm__Stepctx_get, file, "$$$;@");
        (void)newXSproto_portable("Slurm::Stepctx::DESTROY", XS_Slurm__Stepctx_DESTROY, file, "$");
        (void)newXSproto_portable("Slurm::Stepctx::daemon_per_node_hack", XS_Slurm__Stepctx_daemon_per_node_hack, file, "$$$$");
        (void)newXSproto_portable("Slurm::Stepctx::launch", XS_Slurm__Stepctx_launch, file, "$$;$");
        (void)newXSproto_portable("Slurm::Stepctx::launch_wait_start", XS_Slurm__Stepctx_launch_wait_start, file, "$");
        (void)newXSproto_portable("Slurm::Stepctx::launch_wait_finish", XS_Slurm__Stepctx_launch_wait_finish, file, "$");
        (void)newXSproto_portable("Slurm::Stepctx::launch_abort", XS_Slurm__Stepctx_launch_abort, file, "$");
        (void)newXSproto_portable("Slurm::Stepctx::launch_fwd_signal", XS_Slurm__Stepctx_launch_fwd_signal, file, "$$");
        (void)newXSproto_portable("Slurm::api_version", XS_Slurm_api_version, file, "$$$$");
        (void)newXSproto_portable("Slurm::load_ctl_conf", XS_Slurm_load_ctl_conf, file, "$;$");
        (void)newXSproto_portable("Slurm::print_ctl_conf", XS_Slurm_print_ctl_conf, file, "$$$");
        (void)newXSproto_portable("Slurm::ctl_conf_2_key_pairs", XS_Slurm_ctl_conf_2_key_pairs, file, "$$");
        (void)newXSproto_portable("Slurm::load_slurmd_status", XS_Slurm_load_slurmd_status, file, "$");
        (void)newXSproto_portable("Slurm::print_slurmd_status", XS_Slurm_print_slurmd_status, file, "$$$");
        (void)newXSproto_portable("Slurm::print_key_pairs", XS_Slurm_print_key_pairs, file, "$$$$");
        (void)newXSproto_portable("Slurm::update_step", XS_Slurm_update_step, file, "$$");
        (void)newXSproto_portable("Slurm::job_cpus_allocated_on_node_id", XS_Slurm_job_cpus_allocated_on_node_id, file, "$$$");
        (void)newXSproto_portable("Slurm::job_cpus_allocated_on_node", XS_Slurm_job_cpus_allocated_on_node, file, "$$$");
        (void)newXSproto_portable("Slurm::job_info_msg_t::DESTROY", XS_Slurm__job_info_msg_t_DESTROY, file, "$");
        (void)newXSproto_portable("Slurm::get_end_time", XS_Slurm_get_end_time, file, "$$");
        (void)newXSproto_portable("Slurm::get_rem_time", XS_Slurm_get_rem_time, file, "$$");
        (void)newXSproto_portable("Slurm::job_node_ready", XS_Slurm_job_node_ready, file, "$$");
        (void)newXSproto_portable("Slurm::load_job", XS_Slurm_load_job, file, "$$;$");
        (void)newXSproto_portable("Slurm::load_jobs", XS_Slurm_load_jobs, file, "$;$$");
        (void)newXSproto_portable("Slurm::notify_job", XS_Slurm_notify_job, file, "$$$");
        (void)newXSproto_portable("Slurm::pid2jobid", XS_Slurm_pid2jobid, file, "$$");
        (void)newXSproto_portable("Slurm::print_job_info", XS_Slurm_print_job_info, file, "$$$;$");
        (void)newXSproto_portable("Slurm::print_job_info_msg", XS_Slurm_print_job_info_msg, file, "$$$;$");
        (void)newXSproto_portable("Slurm::sprint_job_info", XS_Slurm_sprint_job_info, file, "$$;$");
        (void)newXSproto_portable("Slurm::update_job", XS_Slurm_update_job, file, "$$");
        (void)newXSproto_portable("Slurm::get_job_steps", XS_Slurm_get_job_steps, file, "$;$$$$");
        (void)newXSproto_portable("Slurm::print_job_step_info_msg", XS_Slurm_print_job_step_info_msg, file, "$$$;$");
        (void)newXSproto_portable("Slurm::print_job_step_info", XS_Slurm_print_job_step_info, file, "$$$;$");
        (void)newXSproto_portable("Slurm::sprint_job_step_info", XS_Slurm_sprint_job_step_info, file, "$$;$");
        (void)newXSproto_portable("Slurm::job_step_layout_get", XS_Slurm_job_step_layout_get, file, "$$$");
        (void)newXSproto_portable("Slurm::job_step_stat", XS_Slurm_job_step_stat, file, "$$$$;$");
        (void)newXSproto_portable("Slurm::job_step_get_pids", XS_Slurm_job_step_get_pids, file, "$$$;$");
        (void)newXSproto_portable("Slurm::node_info_msg_t::DESTROY", XS_Slurm__node_info_msg_t_DESTROY, file, "$");
        (void)newXSproto_portable("Slurm::load_node", XS_Slurm_load_node, file, "$;$$");
        (void)newXSproto_portable("Slurm::load_single_node", XS_Slurm_load_single_node, file, "$$;$");
        (void)newXSproto_portable("Slurm::print_node_info_msg", XS_Slurm_print_node_info_msg, file, "$$$;$");
        (void)newXSproto_portable("Slurm::print_node_table", XS_Slurm_print_node_table, file, "$$$;$");
        (void)newXSproto_portable("Slurm::sprint_node_table", XS_Slurm_sprint_node_table, file, "$$;$");
        (void)newXSproto_portable("Slurm::update_node", XS_Slurm_update_node, file, "$$");
        (void)newXSproto_portable("Slurm::load_topo", XS_Slurm_load_topo, file, "$");
        (void)newXSproto_portable("Slurm::print_topo_info_msg", XS_Slurm_print_topo_info_msg, file, "$$$;$");
        (void)newXSproto_portable("Slurm::print_topo_record", XS_Slurm_print_topo_record, file, "$$$;$");
        (void)newXSproto_portable("Slurm::get_select_nodeinfo", XS_Slurm_get_select_nodeinfo, file, "$$$$$");
        (void)newXSproto_portable("Slurm::load_partitions", XS_Slurm_load_partitions, file, "$;$$");
        (void)newXSproto_portable("Slurm::print_partition_info_msg", XS_Slurm_print_partition_info_msg, file, "$$$;$");
        (void)newXSproto_portable("Slurm::print_partition_info", XS_Slurm_print_partition_info, file, "$$$;$");
        (void)newXSproto_portable("Slurm::sprint_partition_info", XS_Slurm_sprint_partition_info, file, "$$;$");
        (void)newXSproto_portable("Slurm::create_partition", XS_Slurm_create_partition, file, "$$");
        (void)newXSproto_portable("Slurm::update_partition", XS_Slurm_update_partition, file, "$$");
        (void)newXSproto_portable("Slurm::delete_partition", XS_Slurm_delete_partition, file, "$$");
        (void)newXSproto_portable("Slurm::load_reservations", XS_Slurm_load_reservations, file, "$;$");
        (void)newXSproto_portable("Slurm::create_reservation", XS_Slurm_create_reservation, file, "$$");
        (void)newXSproto_portable("Slurm::update_reservation", XS_Slurm_update_reservation, file, "$$");
        (void)newXSproto_portable("Slurm::delete_reservation", XS_Slurm_delete_reservation, file, "$$");
        (void)newXSproto_portable("Slurm::print_reservation_info_msg", XS_Slurm_print_reservation_info_msg, file, "$$$;$");
        (void)newXSproto_portable("Slurm::print_reservation_info", XS_Slurm_print_reservation_info, file, "$$$;$");
        (void)newXSproto_portable("Slurm::sprint_reservation_info", XS_Slurm_sprint_reservation_info, file, "$$;$");
        (void)newXSproto_portable("Slurm::ping", XS_Slurm_ping, file, "$;$");
        (void)newXSproto_portable("Slurm::reconfigure", XS_Slurm_reconfigure, file, "$");
        (void)newXSproto_portable("Slurm::shutdown", XS_Slurm_shutdown, file, "$;$");
        (void)newXSproto_portable("Slurm::takeover", XS_Slurm_takeover, file, "$;$");
        (void)newXSproto_portable("Slurm::set_debug_level", XS_Slurm_set_debug_level, file, "$$");
        (void)newXSproto_portable("Slurm::set_schedlog_level", XS_Slurm_set_schedlog_level, file, "$$");
        (void)newXSproto_portable("Slurm::suspend", XS_Slurm_suspend, file, "$$");
        (void)newXSproto_portable("Slurm::resume", XS_Slurm_resume, file, "$$");
        (void)newXSproto_portable("Slurm::requeue", XS_Slurm_requeue, file, "$$$");
        (void)newXSproto_portable("Slurm::checkpoint_able", XS_Slurm_checkpoint_able, file, "$$$$");
        (void)newXSproto_portable("Slurm::checkpoint_disable", XS_Slurm_checkpoint_disable, file, "$$$");
        (void)newXSproto_portable("Slurm::checkpoint_enable", XS_Slurm_checkpoint_enable, file, "$$$");
        (void)newXSproto_portable("Slurm::checkpoint_create", XS_Slurm_checkpoint_create, file, "$$$$$");
        (void)newXSproto_portable("Slurm::checkpoint_requeue", XS_Slurm_checkpoint_requeue, file, "$$$$");
        (void)newXSproto_portable("Slurm::checkpoint_vacate", XS_Slurm_checkpoint_vacate, file, "$$$$$");
        (void)newXSproto_portable("Slurm::checkpoint_restart", XS_Slurm_checkpoint_restart, file, "$$$$$");
        (void)newXSproto_portable("Slurm::checkpoint_complete", XS_Slurm_checkpoint_complete, file, "$$$$$$");
        (void)newXSproto_portable("Slurm::checkpoint_error", XS_Slurm_checkpoint_error, file, "$$$$$");
        (void)newXSproto_portable("Slurm::checkpoint_tasks", XS_Slurm_checkpoint_tasks, file, "$$$$$$$");
        (void)newXSproto_portable("Slurm::set_trigger", XS_Slurm_set_trigger, file, "$$");
        (void)newXSproto_portable("Slurm::clear_trigger", XS_Slurm_clear_trigger, file, "$$");
        (void)newXSproto_portable("Slurm::get_triggers", XS_Slurm_get_triggers, file, "$");
        (void)newXSproto_portable("Slurm::pull_trigger", XS_Slurm_pull_trigger, file, "$$");
        (void)newXSproto_portable("Slurm::Hostlist::create", XS_Slurm__Hostlist_create, file, "$");
        (void)newXSproto_portable("Slurm::Hostlist::count", XS_Slurm__Hostlist_count, file, "$");
        (void)newXSproto_portable("Slurm::Hostlist::find", XS_Slurm__Hostlist_find, file, "$$");
        (void)newXSproto_portable("Slurm::Hostlist::push", XS_Slurm__Hostlist_push, file, "$$");
        (void)newXSproto_portable("Slurm::Hostlist::push_host", XS_Slurm__Hostlist_push_host, file, "$$");
        (void)newXSproto_portable("Slurm::Hostlist::ranged_string", XS_Slurm__Hostlist_ranged_string, file, "$");
        (void)newXSproto_portable("Slurm::Hostlist::shift", XS_Slurm__Hostlist_shift, file, ";$");
        (void)newXSproto_portable("Slurm::Hostlist::uniq", XS_Slurm__Hostlist_uniq, file, "$");
        (void)newXSproto_portable("Slurm::Hostlist::DESTROY", XS_Slurm__Hostlist_DESTROY, file, "$");
        (void)newXSproto_portable("Slurm::List::count", XS_Slurm__List_count, file, "$");
        (void)newXSproto_portable("Slurm::List::is_empty", XS_Slurm__List_is_empty, file, "$");
        (void)newXSproto_portable("Slurm::List::DESTROY", XS_Slurm__List_DESTROY, file, "$");
        (void)newXSproto_portable("Slurm::ListIterator::create", XS_Slurm__ListIterator_create, file, "$");
        (void)newXSproto_portable("Slurm::ListIterator::reset", XS_Slurm__ListIterator_reset, file, "$");
        (void)newXSproto_portable("Slurm::ListIterator::DESTROY", XS_Slurm__ListIterator_DESTROY, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::alloc", XS_Slurm__Bitstr_alloc, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::copy", XS_Slurm__Bitstr_copy, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::test", XS_Slurm__Bitstr_test, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::set", XS_Slurm__Bitstr_set, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::clear", XS_Slurm__Bitstr_clear, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::nset", XS_Slurm__Bitstr_nset, file, "$$$");
        (void)newXSproto_portable("Slurm::Bitstr::nclear", XS_Slurm__Bitstr_nclear, file, "$$$");
        (void)newXSproto_portable("Slurm::Bitstr::ffc", XS_Slurm__Bitstr_ffc, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::ffs", XS_Slurm__Bitstr_ffs, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::fls", XS_Slurm__Bitstr_fls, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::nffc", XS_Slurm__Bitstr_nffc, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::nffs", XS_Slurm__Bitstr_nffs, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::noc", XS_Slurm__Bitstr_noc, file, "$$$");
        (void)newXSproto_portable("Slurm::Bitstr::size", XS_Slurm__Bitstr_size, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::and", XS_Slurm__Bitstr_and, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::not", XS_Slurm__Bitstr_not, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::or", XS_Slurm__Bitstr_or, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::copybits", XS_Slurm__Bitstr_copybits, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::set_count", XS_Slurm__Bitstr_set_count, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::set_count_range", XS_Slurm__Bitstr_set_count_range, file, "$$$");
        (void)newXSproto_portable("Slurm::Bitstr::clear_count", XS_Slurm__Bitstr_clear_count, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::nset_max_count", XS_Slurm__Bitstr_nset_max_count, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::rotate_copy", XS_Slurm__Bitstr_rotate_copy, file, "$$$");
        (void)newXSproto_portable("Slurm::Bitstr::rotate", XS_Slurm__Bitstr_rotate, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::fmt", XS_Slurm__Bitstr_fmt, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::unfmt", XS_Slurm__Bitstr_unfmt, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::fmt2int", XS_Slurm__Bitstr_fmt2int, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::fmt_hexmask", XS_Slurm__Bitstr_fmt_hexmask, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::unfmt_hexmask", XS_Slurm__Bitstr_unfmt_hexmask, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::fmt_binmask", XS_Slurm__Bitstr_fmt_binmask, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::unfmt_binmask", XS_Slurm__Bitstr_unfmt_binmask, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::fill_gaps", XS_Slurm__Bitstr_fill_gaps, file, "$");
        (void)newXSproto_portable("Slurm::Bitstr::super_set", XS_Slurm__Bitstr_super_set, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::overlap", XS_Slurm__Bitstr_overlap, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::equal", XS_Slurm__Bitstr_equal, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::pick_cnt", XS_Slurm__Bitstr_pick_cnt, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::get_bit_num", XS_Slurm__Bitstr_get_bit_num, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::get_pos_num", XS_Slurm__Bitstr_get_pos_num, file, "$$");
        (void)newXSproto_portable("Slurm::Bitstr::DESTROY", XS_Slurm__Bitstr_DESTROY, file, "$");
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

